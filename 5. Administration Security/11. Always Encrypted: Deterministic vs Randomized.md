# 11. Always Encrypted: Deterministic vs Randomized

Canonical documentation for [11. Always Encrypted: Deterministic vs Randomized](5. Administration Security/11. Always Encrypted: Deterministic vs Randomized.md). This document defines concepts, terminology, and standard usage.

## Purpose
The purpose of Always Encrypted technology is to ensure that sensitive data is never seen in plaintext by the database management system (DBMS) or the hosting environment. By encrypting data on the client side before it reaches the server, the technology protects data from high-privileged users (such as database administrators) and potential infrastructure breaches. 

The distinction between Deterministic and Randomized encryption exists to address the fundamental trade-off between data security and database functionality. This documentation defines how these two methods balance the need for server-side operations (like searching and grouping) against the risk of cryptanalysis.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the cryptographic behavior rather than specific software vendor syntax.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The mathematical and functional differences between Deterministic and Randomized encryption.
> * Use cases for searchable vs. non-searchable encrypted data.
> * Security implications of ciphertext patterns.
> * Impact on database indexing and query execution.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., Microsoft SQL Server, MongoDB, Oracle).
> * Key management protocols and hardware security module (HSM) configurations.
> * Performance benchmarking of specific hardware.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Plaintext | The original, unencrypted data in a human-readable or application-usable format. |
| Ciphertext | The encrypted version of the data, which appears as a random string of bytes to the database. |
| Deterministic Encryption | An encryption method that always generates the same ciphertext for a given plaintext and encryption key. |
| Randomized Encryption | An encryption method that generates different ciphertext for the same plaintext every time it is encrypted, typically using a unique initialization vector (IV). |
| Frequency Analysis | A cryptanalytic technique used to decipher data by studying the frequency of repeating patterns in ciphertext. |
| Initialization Vector (IV) | A random or pseudo-random value used as an input to the encryption algorithm to ensure unique ciphertext. |

## Core Concepts
The core of Always Encrypted lies in the location of the encryption keys. Because the database does not possess the keys, it cannot decrypt the data. Therefore, the database must treat the data as opaque blobs.

### The Determinism Trade-off
Deterministic encryption allows the database to perform equality comparisons. If the plaintext "John" always encrypts to "0xABC123," the database can find all records where the name is "0xABC123" without knowing that it represents "John."

Randomized encryption breaks this ability. If "John" encrypts to "0xXYZ789" in one row and "0xLMN456" in another, the database cannot correlate them.

> [!TIP]
> Think of Deterministic encryption like a "blind index." You can find a match because the labels are consistent, but you cannot read the contents of the package. Randomized encryption is like a "black box" where even the labels change every time, making it impossible to organize or search without opening the box (decrypting).

## Standard Model
The standard model for implementing Always Encrypted involves selecting the encryption type based on the column's role in the application logic.

### Deterministic Model
*   **Functionality:** Supports point lookups (WHERE col = 'value'), equality joins, and GROUP BY operations.
*   **Indexing:** Allows for the creation of indexes on encrypted columns, as the ciphertext remains stable.
*   **Security:** Lower than randomized. It is vulnerable to frequency analysis if the data distribution is known.

### Randomized Model
*   **Functionality:** Does not support any server-side operations. Data can only be retrieved and decrypted by the client.
*   **Indexing:** Generally does not support indexing for search purposes, as the ciphertext for the same value varies.
*   **Security:** Maximum security. It prevents frequency analysis and pattern matching.

## Common Patterns
1.  **Searchable Identifiers:** Use Deterministic encryption for columns used as lookup keys, such as Social Security Numbers, Employee IDs, or National Identity numbers.
2.  **Sensitive Descriptive Data:** Use Randomized encryption for columns containing notes, comments, or medical histories where searching by exact match is not required.
3.  **Foreign Keys:** Use Deterministic encryption for columns that serve as join keys between two encrypted tables to maintain relational integrity at the ciphertext level.

## Anti-Patterns
1.  **Low-Entropy Determinism:** Using Deterministic encryption on columns with very few possible values (e.g., "True/False," "Gender," or "Status").
    > [!CAUTION]
    > If an attacker knows a column only contains "Yes" or "No," and they see that 90% of the ciphertext is "0x111" and 10% is "0x222," they can easily deduce the plaintext through frequency analysis.
2.  **Over-Encryption:** Using Randomized encryption on every column regardless of use case. This leads to severe performance degradation and forces the application to pull all data to the client for filtering.
3.  **Mixing Types on Join Keys:** Attempting to join a Deterministically encrypted column with a Randomized encrypted column. This will result in zero matches and query failure.

## Edge Cases
*   **Collation Sensitivity:** In many database systems, Deterministic encryption is sensitive to the underlying collation (e.g., case sensitivity). If "smith" and "Smith" are treated as different plaintexts, they will produce different ciphertexts, potentially breaking search logic if the application expects case-insensitivity.
*   **Null Values:** Most implementations do not encrypt NULL values to allow the database to optimize for nullability. This means the presence of data (or lack thereof) is leaked to the server.
*   **Data Type Conversions:** Implicit conversions (e.g., comparing an encrypted INT to an encrypted BIGINT) usually fail because the ciphertexts will not match, even if the underlying numeric value is the same.

## Related Topics
*   **Client-Side vs. Server-Side Encryption:** Understanding where the "Trust Boundary" lies.
*   **Key Management Systems (KMS):** How to store and rotate the Column Master Keys (CMK).
*   **In-Place Encryption:** The process of converting plaintext columns to encrypted columns without moving data off-site.
*   **Homomorphic Encryption:** An emerging field that allows mathematical operations (like addition) on ciphertext, which Always Encrypted does not support.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |