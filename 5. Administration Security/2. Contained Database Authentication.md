# 2. Contained Database Authentication

Canonical documentation for [2. Contained Database Authentication](5. Administration Security/2. Contained Database Authentication.md). This document defines concepts, terminology, and standard usage.

## Purpose
The purpose of Contained Database Authentication is to decouple a database's security identity from the hosting instance or server environment. In traditional database models, authentication is a two-step process involving a server-level login mapped to a database-level user. This creates a dependency on the host environment, complicating database portability and migration.

Contained Database Authentication addresses these challenges by allowing the database to store its own authentication metadata. This enables users to authenticate directly against the database without requiring a corresponding login at the instance level, facilitating "portable" databases that can be moved between different hosts with minimal reconfiguration.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural shift from server-centric to database-centric identity management.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The mechanism of storing authentication metadata within the database boundary.
> * The lifecycle of a contained user identity.
> * The logical separation between instance-level and database-level security principals.
> * Portability and isolation benefits.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific syntax (e.g., T-SQL or PL/SQL commands).
> * Network-level authentication protocols (e.g., Kerberos, TLS handshakes).
> * Cloud-specific identity providers (e.g., Entra ID, AWS IAM) unless used as a generic example of external containment.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Authentication Boundary | The logical perimeter defining where identity verification occurs (either at the instance level or the database level). |
| Contained User | A security principal defined entirely within a database that does not have a linked login in the hosting instance. |
| Instance-level Login | A security principal defined at the server or cluster level, traditionally required to access the environment before reaching a specific database. |
| Metadata Containment | The state where all information required to define and authenticate a user is stored within the database's own data files. |
| Uncontained Entity | Any object or security dependency that relies on information stored outside the specific database (e.g., in a master or system database). |

## Core Concepts
The fundamental idea behind Contained Database Authentication is the shift of the "Source of Truth" for identity.

**The Authentication Boundary**
In a non-contained model, the authentication boundary sits at the Instance level. A user must first pass through the "gate" of the server. In a contained model, the boundary is moved to the Database level. The database itself becomes the authority for verifying credentials.

> [!TIP]
> Think of a traditional login like a building security badge (Instance) that grants access to the lobby, after which you need a specific key for an office (Database). Contained authentication is like having a digital keypad on the office door itself; if you have the code, you don't need the building badge to enter the room.

**Isolation and Portability**
Because the authentication information (usernames, password hashes, or external provider references) travels with the database backups or data files, the database is "self-describing" from a security perspective. This eliminates the "Orphaned User" problem, where a database is restored to a new server but the users cannot log in because the new server lacks the original instance-level logins.

## Standard Model
The standard model for Contained Database Authentication follows a specific resolution order:

1.  **Connection Request:** The client specifies the target database in the connection string (Initial Catalog/Database).
2.  **Identity Identification:** The database engine checks if the database is configured for containment.
3.  **Local Lookup:** The engine searches the databaseâ€™s internal metadata for the provided username.
4.  **Verification:**
    *   If the user is a **Database User with Password**, the engine verifies the password hash stored within the database.
    *   If the user is an **External Contained User**, the engine facilitates a handshake with an external identity provider (e.g., an LDAP or OIDC provider) based on the metadata in the database.
5.  **Access Granted:** Upon successful verification, the session is established directly within the database context.

## Common Patterns
*   **Database Migration/Failover:** Using contained authentication to ensure that when a database is moved to a secondary site or a different server, all users retain access without manual intervention by a System Administrator.
*   **Multi-tenant Isolation:** In environments where multiple clients share an instance, containment ensures that Tenant A's users are completely invisible to Tenant B and have no footprint in the system-level tables.
*   **DevOps/CI-CD:** Developers can define security schemas within their source control that are fully functional upon deployment to any environment, as no server-level configuration is required.

## Anti-Patterns
*   **Mixed Dependency:** Creating a contained database but still using cross-database queries that rely on instance-level permissions. This breaks the "containment" and prevents portability.
*   **Duplicate Identities:** Maintaining both an instance-level login and a contained database user with the same name but different credentials, leading to "Ambiguous Identity" errors.
*   **Ignoring Collation:** In some implementations, the collation of the database must match the instance for contained authentication to function correctly during metadata lookups.

> [!CAUTION]
> Avoid circular dependencies where a contained user requires permissions on a system-level resource to perform basic database tasks. This effectively nullifies the benefits of containment.

## Edge Cases
*   **Password Policy Enforcement:** Since the database manages the password, instance-level password complexity or expiration policies may not automatically apply unless specifically integrated with an external provider.
*   **Renaming Databases:** If authentication metadata is tied to the database name (in certain external provider scenarios), renaming the database may break the authentication link.
*   **System Administrator Override:** Even in a fully contained model, the instance-level administrator (e.g., `sa` or `root`) typically retains the ability to enter the database, acting as a "backdoor" that bypasses the containment boundary.

## Related Topics
*   **Database Portability:** The broader concept of moving databases between environments.
*   **Orphaned Users:** The specific problem state that contained authentication is designed to solve.
*   **External Identity Providers (IdP):** Systems that manage identity outside of the database engine.
*   **Instance-Level Security:** The traditional model of database security.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |