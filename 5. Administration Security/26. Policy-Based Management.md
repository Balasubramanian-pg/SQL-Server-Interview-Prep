# 26. Policy Based Management

Canonical documentation for 26. Policy Based Management. This document defines concepts, terminology, and standard usage.

## Purpose
Policy Based Management (PBM) exists to decouple the "what" (intent and rules) from the "how" (implementation and execution) in complex systems. As environments scale, manual configuration becomes error-prone and unsustainable. PBM addresses this by providing a framework where high-level business or operational requirements are translated into automated, enforceable rules.

The primary objective of PBM is to ensure consistency, security, and compliance across heterogeneous environments by centralizing the logic that governs system behavior. It allows administrators to manage systems by defining desired states and constraints rather than executing individual commands on discrete components.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural patterns and logical frameworks that underpin all policy-driven systems.

## Scope
This documentation covers the theoretical and structural foundations of Policy Based Management applicable to software engineering, network administration, cloud infrastructure, and data governance.

> [!IMPORTANT]
> **In scope:**
> * The logical architecture of policy systems (PAP, PDP, PEP, PIP).
> * Declarative vs. Imperative policy models.
> * Policy lifecycle management.
> * Conflict resolution strategies.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., AWS IAM, Kubernetes Admission Controllers, Cisco DNA Center).
> * Specific policy languages (e.g., Rego, XACML, YAML-based schemas).
> * Legal or regulatory text analysis (focus is on technical enforcement).

## Definitions
| Term | Definition |
|------|------------|
| Policy | A set of rules or constraints that govern the behavior of a system. |
| Policy Administration Point (PAP) | The entity where policies are created, managed, and stored. |
| Policy Decision Point (PDP) | The engine that evaluates a request against applicable policies to reach a verdict. |
| Policy Enforcement Point (PEP) | The component that intercepts requests and enforces the decision made by the PDP. |
| Policy Information Point (PIP) | The source of truth for external data (attributes) required to evaluate a policy. |
| Declarative Policy | A policy that describes the desired end-state without specifying the steps to achieve it. |
| Imperative Policy | A policy that defines a specific sequence of actions to be taken under certain conditions. |
| Conflict Resolution | The logic used to determine the outcome when two or more policies provide contradictory instructions. |

## Core Concepts

### Separation of Concerns
The fundamental principle of PBM is the separation of policy logic from application logic. By isolating rules into a dedicated layer, organizations can update security or operational constraints without modifying the underlying source code or infrastructure.

### The Policy Lifecycle
Policies are not static; they follow a continuous lifecycle:
1.  **Definition:** Authoring the policy based on requirements.
2.  **Validation:** Testing the policy for syntax and logical errors.
3.  **Distribution:** Deploying the policy to the relevant decision points.
4.  **Evaluation:** Comparing real-time requests against the policy.
5.  **Enforcement:** Executing the decision (Allow, Deny, Obligate).
6.  **Audit:** Reviewing logs to ensure the policy is achieving the intended outcome.

> [!TIP]
> Think of Policy Based Management like a thermostat. You set the "Policy" (desired temperature). The "PDP" (the thermostat's logic) compares the "PIP" (current room temperature) to the policy. The "PEP" (the HVAC system) then turns on or off to align the actual state with the desired state.

## Standard Model
The standard model for PBM follows the **Reference Architecture for Policy-Based Control**. This model ensures that every request within a system is mediated by a policy layer.

1.  **Request:** A subject (user/service) attempts an action on a resource.
2.  **Interception:** The **PEP** intercepts the request and asks the **PDP** for a decision.
3.  **Context Retrieval:** The **PDP** queries the **PIP** for necessary attributes (e.g., user roles, time of day, resource sensitivity).
4.  **Evaluation:** The **PDP** retrieves the relevant policy from the **PAP** and evaluates the request.
5.  **Decision:** The **PDP** returns a decision (e.g., Permit, Deny, Indeterminate, Not Applicable).
6.  **Enforcement:** The **PEP** allows or blocks the request and may perform "Obligations" (e.g., logging the event or encrypting the output).

## Common Patterns

### Attribute-Based Access Control (ABAC)
A flexible pattern where policies use attributes (Subject, Resource, Action, Environment) to make decisions. This allows for highly granular and context-aware rules.

### Role-Based Access Control (RBAC)
A simplified pattern where policies are tied to defined roles. While easier to manage at a small scale, it often leads to "role explosion" in complex environments.

### Just-in-Time (JIT) Policy
Policies that grant temporary elevated privileges or change system behavior for a specific window of time, reducing the attack surface.

### Centralized Administration, Distributed Enforcement
Policies are authored in a single location (Central PAP) but enforced locally at the edge (Distributed PEPs). This ensures consistency while maintaining low latency and high availability.

## Anti-Patterns

### Hard-coded Logic
Embedding policy rules directly into the application code. This makes auditing impossible and requires a full deployment cycle to change a simple rule.

### Policy Bloat
Creating thousands of granular policies without a hierarchy or inheritance model. This leads to "Policy Entropy," where it becomes impossible to predict the outcome of a request.

### Shadow Policies
Implementing "hidden" rules at the infrastructure level (e.g., manual firewall rules) that contradict or bypass the formal Policy Based Management system.

> [!CAUTION]
> Avoid circular dependencies where the Policy Decision Point (PDP) requires a policy to access the Policy Information Point (PIP) that it needs to evaluate the original policy. This can lead to system deadlocks.

## Edge Cases

### Fail-Open vs. Fail-Closed
In the event that the PDP is unreachable, the PEP must have a default behavior. 
*   **Fail-Closed:** Denies all requests. This is the most secure but can cause total system outages.
*   **Fail-Open:** Allows all requests. This maintains availability but creates a significant security risk.

### Policy Conflict (Deny Overrides)
When one policy allows an action and another denies it, a standard resolution must be defined. Most authoritative systems implement a "Deny Overrides" principle, where a single "Deny" verdict trumps any number of "Allow" verdicts.

### Stale Policy Cache
In distributed systems, PEPs often cache policy decisions to improve performance. If a policy is revoked in the PAP, there may be a "window of vulnerability" where the PEP continues to enforce the old, cached policy.

## Related Topics
*   **Identity and Access Management (IAM):** The primary consumer of PBM for security.
*   **Infrastructure as Code (IaC):** The practice of defining infrastructure through declarative files, often governed by PBM.
*   **Governance, Risk, and Compliance (GRC):** The high-level business framework that informs policy definitions.
*   **Observability and Telemetry:** Necessary for auditing policy enforcement and feeding the PIP.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |