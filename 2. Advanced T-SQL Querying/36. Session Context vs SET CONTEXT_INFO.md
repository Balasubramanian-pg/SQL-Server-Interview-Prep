# 36. Session Context vs SET CONTEXT INFO

### 1. The Anchor
* **One-Sentence Pitch:** These are two distinct mechanisms in SQL Server used to store and retrieve session-scoped state, with `SESSION_CONTEXT` being the modern, secure, and flexible successor to the legacy `CONTEXT_INFO`.
* **Category:** Database Engineering / T-SQL Development

### 2. The Mechanics
* **Key Detail A: SET CONTEXT_INFO (Legacy):** This method provides a single `VARBINARY(128)` buffer per session. It is limited to 128 bytes and requires manual casting and padding to store multiple values. It is accessed via the `CONTEXT_INFO()` function or the `sys.dm_exec_sessions` DMV.
* **Key Detail B: SESSION_CONTEXT (Modern):** Introduced in SQL Server 2016, this is a key-value pair store that supports multiple variables per session. It handles various data types (up to 256KB total) and includes a `read_only` flag to prevent subsequent modification within the same session. It is managed via `sp_set_session_context` and retrieved via `SESSION_CONTEXT()`.
* **The Logic:** These tools solve the problem of "stateless" database objects. Since triggers and views cannot accept parameters, session context allows an application to "pass" metadata (like a UserID or TenantID) into the database execution scope. This is critical for auditing and Row-Level Security (RLS).

> [!IMPORTANT]
> `SESSION_CONTEXT` is generally preferred over `CONTEXT_INFO` because it is easier to use, supports more data, and provides a security layer via the `read_only` parameter which prevents "context hijacking" by malicious scripts.

### 3. The Evidence
* **Context (CAR/STAR):** I was tasked with implementing a robust auditing system for a multi-tenant financial application where all database connections were made via a single application service account, making it impossible to identify the actual user via `SUSER_SNAME()`.
* **Action:** I replaced the existing, fragile `CONTEXT_INFO` implementation—which required complex bitmasking to store both a `UserID` and a `CorrelationID`—with `SESSION_CONTEXT`. I utilized the `@read_only = 1` parameter during the initial session setup in the application's connection logic.
* **Result:** This migration eliminated binary parsing errors in our triggers and secured the `TenantID` against accidental or intentional modification during the session. It also reduced the complexity of our audit triggers by 30%, as they could now perform direct key-value lookups.

> [!TIP]
> When using `SESSION_CONTEXT`, always use a consistent naming convention for keys (e.g., `user_id`, `app_name`) to ensure maintainability across different stored procedures and triggers.

### 4. The Interview "Pivot"
* **Triggers:** "How do you handle Row-Level Security?", "How do you pass information to a trigger?", or "What are the differences between legacy and modern T-SQL features?"
* **The Connection:** This topic allows me to demonstrate my understanding of database security and state management. By explaining why `SESSION_CONTEXT` is superior to `CONTEXT_INFO`, I show that I stay current with SQL Server advancements and prioritize secure-by-design principles, such as using the `read_only` flag to prevent privilege escalation or data leakage in multi-tenant environments.

> [!WARNING]
> Be aware that `CONTEXT_INFO` is reset to NULL when a connection is returned to a connection pool in some environments, whereas `SESSION_CONTEXT` persists for the duration of the session. Always explicitly clear or reset context when using connection pooling to avoid "bleeding" state between different logical users.