# 58. Deterministic vs Non Deterministic Functions

### 1. The Anchor
* **One-Sentence Pitch:** Deterministic functions consistently produce the same output for a given set of inputs, whereas non-deterministic functions return varying results based on external state, time, or randomness, fundamentally dictating how systems optimize, cache, and index data.
* **Category:** Technical Skill / Database Architecture / Software Engineering

### 2. The Mechanics
* **Key Detail A: The Rule of Consistency:** A function is deterministic if, and only if, it is "pure"â€”meaning it has no side effects and its return value is derived solely from its input parameters. Examples include mathematical operations like `ABS()` or string manipulations like `UPPER()`.
* **Key Detail B: The Volatility of State:** Non-deterministic functions rely on external factors such as the system clock (`GETDATE()`), global state, or random number generators (`RAND()`). Because their output can change even when inputs remain identical, they are considered volatile.
* **The Logic:** This distinction is critical for performance optimization. Compilers and database query optimizers can "memoize" or cache the results of deterministic functions (Constant Folding). Conversely, non-deterministic functions must be re-evaluated every time they are called, preventing them from being used in persisted computed columns or certain types of indexed views.

> [!IMPORTANT]
> In database management systems (DBMS), a function must be deterministic to be used in a persisted computed column or a filtered index. If the engine cannot guarantee the value will remain the same, it cannot safely store that value in a physical index.

### 3. The Evidence
* **Context (CAR/STAR):** While optimizing a high-traffic financial reporting system, I discovered a performance bottleneck in a query filtering millions of records based on a "Days Since Transaction" calculation.
* **Action:** I identified that the query was using a non-deterministic function (`DATEDIFF(day, TransactionDate, GETDATE())`) directly in the `WHERE` clause, which forced a full table scan because the optimizer could not use the index on `TransactionDate`. I refactored the logic to calculate the target date range into a static variable before the query execution, transforming the filter into a deterministic range comparison.
* **Result:** This change allowed the database to utilize index seeking instead of scanning, reducing the query execution time from 15 seconds to under 200 milliseconds and significantly lowering CPU utilization on the production server.

> [!TIP]
> When writing APIs or Microservices, treat determinism as a goal for business logic. Deterministic logic is significantly easier to unit test because it eliminates the need for complex mocking of system clocks or random states.

### 4. The Interview "Pivot"
* **Triggers:** "How do you handle query optimization?", "What are the benefits of pure functions in functional programming?", "Why can't we index this specific column?", or "Tell me about a time you solved a scaling issue."
* **The Connection:** This topic allows me to pivot from basic coding to high-level system design. It proves that I understand the "under-the-hood" behavior of execution engines. By discussing determinism, I demonstrate that I write code with an awareness of caching layers, indexing limitations, and computational efficiency, ensuring that the applications I build are performant at scale.

> [!WARNING]
> Be cautious when using functions like `NEWID()` or `UUID()` in joins or filters. Their non-deterministic nature can lead to "Halloween Problems" or unexpected result sets in distributed systems where execution order isn't guaranteed.