# 4. Window Functions: RANK vs DENSE RANK

### 1. The Anchor
* **One-Sentence Pitch:** RANK and DENSE_RANK are window functions used to assign a positional value to rows within a result set, differing exclusively in how they handle ties and subsequent numbering sequences.
* **Category:** Technical Skill / SQL Development & Data Analysis

### 2. The Mechanics
* **Key Detail A: RANK (The "Gap" Approach):** When two or more rows share the same value in the `ORDER BY` clause, `RANK()` assigns them the same rank. However, it "skips" the subsequent ranks to account for the number of tied rows. For example, if two rows tie for 1st place, the next row is ranked 3rd.
* **Key Detail B: DENSE_RANK (The "Continuous" Approach):** Like its counterpart, `DENSE_RANK()` assigns the same rank to tied values. The critical difference is that it does not skip any numbers in the sequence. If two rows tie for 1st place, the next row is ranked 2nd.
* **The Logic:** These functions solve the problem of non-unique ordering. `RANK()` is mathematically consistent with "competition" logic (if two people get Gold, the next person gets Bronze). `DENSE_RANK()` is used when the goal is to identify distinct groups of values (e.g., "What are the top 3 unique price points in our catalog?").

> [!IMPORTANT]
> Both functions require an `OVER()` clause containing an `ORDER BY` sub-clause. Without `ORDER BY`, the ranking is non-deterministic and effectively useless.

> [!TIP]
> If you need a unique integer for every single row regardless of ties, use `ROW_NUMBER()` instead of either ranking function.

### 3. The Evidence
* **Context (CAR/STAR):** A financial services client required a "Top 10" leaderboard for their highest-performing traders. Because multiple traders often hit the exact same performance metrics, using a standard `LIMIT 10` or `ROW_NUMBER()` was excluding qualified individuals who were tied for the 10th spot.
* **Action:** I implemented a Common Table Expression (CTE) using `DENSE_RANK()`. This allowed the system to group all traders with identical performance metrics into the same rank. I then filtered the results where the rank was less than or equal to 10.
* **Result:** This ensured that the leaderboard was "fair" and inclusive of all top performers. The solution was more robust than a simple `TOP` query, as it correctly handled the business logic of "Top 10 Performance Tiers" rather than just "First 10 Rows."

### 4. The Interview "Pivot"
* **Triggers:** "How do you find the Nth highest salary in a table?", "What is the difference between RANK and DENSE_RANK?", or "How do you handle duplicate values when sorting data?"
* **The Connection:** This topic proves I understand the nuance of data integrity. In a production environment, data is rarely unique. By demonstrating mastery over these window functions, I show that I can write queries that reflect complex business rules (like tie-breaking and tiering) rather than just basic CRUD operations. It signals that I am prepared for data engineering and analytical tasks where precision is non-negotiable.

> [!NOTE]
> In most SQL dialects (PostgreSQL, SQL Server, BigQuery, Snowflake), the performance overhead of `RANK()` vs `DENSE_RANK()` is negligible; the choice should be driven entirely by the required business logic.