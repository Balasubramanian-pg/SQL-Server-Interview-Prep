# 15. Derived Tables vs CTEs

### 1. The Anchor
* **One-Sentence Pitch:** Derived Tables and Common Table Expressions (CTEs) are temporary result sets used to modularize complex SQL queries, where CTEs prioritize readability and recursion while Derived Tables provide localized, inline scoping.
* **Category:** Technical Skill / Database Engineering

### 2. The Mechanics
* **Key Detail A: Structural Definition and Scope:** 
    * **Derived Tables** are subqueries located in the `FROM` clause of a `SELECT` statement. They are "unnamed" (though they require an alias) and exist only for the duration of the outer query. They are defined inline: `SELECT * FROM (SELECT ...) AS alias`.
    * **CTEs** are defined at the start of a query using the `WITH` clause. They are "named" result sets that can be referenced multiple times within the same statement, including within other CTEs or the final `SELECT`, `INSERT`, `UPDATE`, or `DELETE` command.
* **Key Detail B: Functional Capabilities:** 
    * **Recursion:** CTEs support recursive logic (Recursive CTEs), allowing for the traversal of hierarchical data like organizational charts or bill-of-materials. Derived tables cannot reference themselves.
    * **Readability:** CTEs follow a top-down logical flow, separating data preparation from the final output. Derived tables often lead to "deeply nested" code that is difficult to read and debug.
* **The Logic:** These constructs solve the problem of query complexity. Without them, developers would be forced to create physical temporary tables or write redundant logic. They allow the SQL optimizer to treat a subset of data as a virtual table, enabling complex aggregations and multi-step transformations within a single execution plan.

> [!TIP]
> Use CTEs for complex logic that requires multiple steps or self-references. Use Derived Tables for simple, one-off transformations where the overhead of a `WITH` clause might over-complicate a short script.

### 3. The Evidence
* **Context (CAR/STAR):** A legacy financial reporting system utilized a 600-line SQL statement with seven levels of nested subqueries (Derived Tables). This structure made it nearly impossible to identify where a specific calculation error was occurring, and the database optimizer was struggling to generate an efficient execution plan.
* **Action:** I refactored the monolithic query by extracting the nested logic into a sequence of five logically named CTEs (e.g., `BaseTransactions`, `CurrencyAdjustments`, `AggregatedTotals`). I isolated the filtering logic into the initial CTEs to reduce the data volume processed in subsequent steps.
* **Result:** The refactoring reduced the code footprint by 25% and improved readability significantly. More importantly, the database optimizer was able to better utilize indexes on the filtered CTEs, resulting in a 40% reduction in query execution time.

> [!IMPORTANT]
> While CTEs improve readability, be aware that in some older database versions (like PostgreSQL prior to v12), CTEs acted as "optimization fences," meaning the optimizer could not push predicates down into the CTE. Always verify the execution plan when performance is critical.

### 4. The Interview "Pivot"
* **Triggers:** "How do you approach writing complex SQL?", "What is the difference between a subquery and a CTE?", or "Tell me about a time you improved code maintainability."
* **The Connection:** This topic proves I don't just write code that "works"â€”I write code that is maintainable, performant, and architecturally sound. It demonstrates an understanding of how the database engine processes logical blocks and shows that I prioritize the long-term lifecycle of the codebase by choosing structures that are easy for teammates to audit and debug.

> [!WARNING]
> Avoid using Derived Tables when the same subquery logic needs to be used twice in a join. This forces the database to evaluate the same logic twice. Use a CTE instead to define the logic once and reference it multiple times.