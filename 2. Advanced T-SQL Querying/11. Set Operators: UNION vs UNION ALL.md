# 11. Set Operators: UNION vs UNION ALL

### 1. The Anchor
* **One-Sentence Pitch:** Set operators allow for the vertical consolidation of multiple result sets into a single output, where `UNION` enforces uniqueness through a deduplication step and `UNION ALL` prioritizes performance by appending all records.
* **Category:** Technical Skill / Database Development & Optimization

### 2. The Mechanics
* **Key Detail A: Structural Requirements:** For any set operation to succeed, the participating `SELECT` statements must adhere to the "Rule of Three": they must have the same number of columns, the columns must be in the same positional order, and the data types must be compatible (e.g., you cannot union a `VARCHAR` with an `INT` without explicit casting).
* **Key Detail B: The Deduplication Process:** `UNION` performs an implicit `DISTINCT` operation across the entire combined result set. To achieve this, the database engine must perform a sort or a hash operation to identify and discard duplicate rows. In contrast, `UNION ALL` performs no such check, simply concatenating the data streams.
* **The Logic:** These operators solve the problem of merging disparate data sources that represent the same entity type. The choice between them is a trade-off between **Data Integrity** (ensuring no duplicates) and **Computational Efficiency** (avoiding the overhead of sorting large datasets).

> [!IMPORTANT]
> Column names in the final result set are typically inherited from the first `SELECT` statement. If you need specific aliases, define them in the initial query.

> [!TIP]
> Always default to `UNION ALL` unless you have a specific requirement to remove duplicates. This avoids unnecessary CPU and memory consumption associated with the sorting/de-duping phase.

### 3. The Evidence
* **Context (CAR/STAR):** While optimizing a financial reconciliation dashboard, I discovered that several views were using `UNION` to combine transaction data from twelve different monthly partition tables.
* **Action:** I audited the underlying data and confirmed that the primary keys (Transaction IDs) were unique across all partitions, making duplicates impossible. I refactored the views to use `UNION ALL` and moved the sorting logic to the final presentation layer rather than the intermediate set operations.
* **Result:** This change reduced the query execution time from 14 seconds to under 2 seconds, as the database engine no longer had to perform a massive sort-merge operation on millions of rows to check for duplicates that didn't exist.

> [!WARNING]
> Using `UNION` on large datasets can lead to "TempDB" or disk spilling if the sort operation exceeds the available memory (RAM) allocated to the database engine.

### 4. The Interview "Pivot"
* **Triggers:** "How do you handle performance tuning in SQL?", "Explain the difference between UNION and UNION ALL," or "How would you combine data from two different legacy systems?"
* **The Connection:** This topic allows me to pivot from basic syntax to architectural awareness. It proves that I don't just write code that *works*, but code that is *performant*. It demonstrates that I understand how the database engine processes data under the hood (sorting, hashing, and memory management) and that I am mindful of resource utilization in production environments.