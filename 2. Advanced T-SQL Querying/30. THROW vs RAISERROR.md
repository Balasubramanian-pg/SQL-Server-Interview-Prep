# 30. THROW vs RAISERROR

### 1. The Anchor
* **One-Sentence Pitch:** `THROW` is the modern, standard-compliant method for raising exceptions in SQL Server that simplifies syntax and ensures batch termination, while `RAISERROR` is the legacy tool used for complex, fine-grained error reporting and severity level management.
* **Category:** Technical Skill / Database Development

### 2. The Mechanics
* **Key Detail A: The Modern Standard (THROW):** Introduced in SQL Server 2012, the `THROW` statement is the preferred method for error handling. It is simpler to use because it does not require an entry in `sys.messages`. Crucially, when used inside a `CATCH` block without parameters, it re-throws the original error that triggered the block, preserving the original error's metadata.
* **Key Detail B: The Legacy Control (RAISERROR):** `RAISERROR` provides granular control over the error's "Severity" (0-25) and "State." It supports C-style string formatting (printf) and can be used to return non-terminating warnings (severity 0-10). However, it does not automatically honor `SET XACT_ABORT ON` in the same way `THROW` does, often requiring additional logic to stop execution.
* **The Logic:** The transition from `RAISERROR` to `THROW` solves the problem of "silent failures" and inconsistent error handling. `THROW` forces a batch termination (severity 16), which aligns SQL Server with the exception-handling patterns found in modern languages like C# or Java. It reduces boilerplate code and ensures that transactions are not left in an orphaned state.

> [!IMPORTANT]
> A `THROW` statement must be preceded by a semicolon (`;`) if it is not the first statement in a batch, as it is not a terminal statement and can be misinterpreted by the parser if the previous statement is not properly terminated.

### 3. The Evidence
* **Context (CAR/STAR):** While refactoring a legacy ETL (Extract, Transform, Load) pipeline, I discovered that several stored procedures were using `RAISERROR` with low severity levels. This caused the process to log an error but continue executing, resulting in partial data loads and corrupted reporting tables.
* **Action:** I implemented a standardized error-handling framework using `BEGIN TRY...BEGIN CATCH` blocks. I replaced all instances of `RAISERROR` with `THROW` to ensure that any critical failure immediately halted the batch and triggered a transaction rollback. I also utilized the parameterless `THROW` in the `CATCH` block to pass the exact system error back to the application layer.
* **Result:** This change eliminated "partial success" scenarios, reduced the time spent on manual data cleanup by 30%, and provided the application team with more accurate stack traces for debugging.

> [!TIP]
> Use `RAISERROR` only when you specifically need to return a message with a severity level lower than 11 (as a warning) or when you need to use the `WITH NOWAIT` option to flush messages to the client immediately.

### 4. The Interview "Pivot"
* **Triggers:** "How do you handle exceptions in T-SQL?", "What is the difference between THROW and RAISERROR?", or "How do you ensure database transaction integrity?"
* **The Connection:** This topic allows me to demonstrate that I don't just write code that "works," but code that is "robust." By explaining the nuances between these two commands, I show an understanding of SQL Server evolution, transaction safety, and the importance of writing maintainable, modern T-SQL that prevents data corruption.

> [!WARNING]
> Unlike `RAISERROR`, `THROW` does not support the `WITH LOG` option directly. If you need to write to the Windows Application Log, you must either use `RAISERROR` or use `sp_altermessage` to force a specific error number to be logged.