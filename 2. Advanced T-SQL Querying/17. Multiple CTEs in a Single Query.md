# 17. Multiple CTEs in a Single Query

### 1. The Anchor
* **One-Sentence Pitch:** Multiple Common Table Expressions (CTEs) enable the decomposition of complex, multi-stage data transformations into a sequence of named, modular, and readable temporary result sets within a single execution scope.
* **Category:** Technical Skill / SQL Development & Data Architecture

### 2. The Mechanics
* **Key Detail A: Sequential Definition and Syntax:** Multiple CTEs are initiated by a single `WITH` keyword. Each subsequent CTE is separated by a comma, and only the final CTE is followed by the primary query (SELECT, INSERT, UPDATE, or DELETE).
* **Key Detail B: Hierarchical Referencing:** A powerful feature of multiple CTEs is that any CTE defined later in the sequence can reference any CTE defined earlier in the same `WITH` clause. This creates a logical pipeline where data is refined step-by-step.
* **The Logic:** This approach replaces deeply nested subqueries—which are processed from the "inside out"—with a linear, top-to-bottom structure. It solves the problem of "Pyramid Code" in SQL, significantly reducing cognitive load for developers and improving the maintainability of complex business logic.

> [!IMPORTANT]
> While multiple CTEs improve readability, they are not always materialized by the query optimizer. In some SQL dialects (like older versions of PostgreSQL), each CTE is evaluated independently, which can impact performance if the same CTE is referenced multiple times.

> [!TIP]
> Use descriptive names for each CTE (e.g., `filtered_sales`, `aggregated_revenue`, `final_metrics`) to serve as internal documentation for the query's logic.

### 3. The Evidence
* **Context (CAR/STAR):** I inherited a legacy financial reporting script that utilized five levels of nested subqueries to calculate year-over-year growth across multiple regions. The query was 300 lines long and nearly impossible to debug when regional tax logic changed.
* **Action:** I refactored the monolithic query into a single `WITH` block containing four distinct CTEs: `raw_transactions`, `regional_adjustments`, `annual_summaries`, and `growth_calculations`. This separated the data ingestion, business logic application, and mathematical aggregation into isolated stages.
* **Result:** The refactoring reduced the total lines of code by 20% and cut the time required for logic updates from hours to minutes. Furthermore, the clear structure allowed the QA team to validate intermediate results at each stage of the CTE pipeline, ensuring 100% data accuracy during the transition.

### 4. The Interview "Pivot"
* **Triggers:** "How do you ensure your SQL code is maintainable?", "Explain your process for debugging complex queries," or "What are the advantages of CTEs over subqueries?"
* **The Connection:** This topic allows me to pivot from basic coding proficiency to high-level engineering standards. It proves that I don't just write code that "works," but code that is architected for longevity, team collaboration, and ease of troubleshooting—essential traits for any senior-level technical role.

> [!WARNING]
> Avoid over-modularizing. Creating twenty CTEs for a simple join can introduce unnecessary overhead. Use multiple CTEs when the logical jump between data states is significant enough to warrant a named boundary.