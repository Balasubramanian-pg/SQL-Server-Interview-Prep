# 34. Table Valued Parameters (TVP)

### 1. The Anchor
* **One-Sentence Pitch:** Table-Valued Parameters (TVPs) allow applications to send multiple rows of structured data to a stored procedure or function as a single parameter, eliminating the need for multiple round-trips or complex string parsing.
* **Category:** Technical Skill / Database Engineering

### 2. The Mechanics
* **Key Detail A: User-Defined Table Types (UDTT):** Before a TVP can be used, a schema must be defined in the database as a `TYPE`. This acts as a blueprint, ensuring the incoming data strictly adheres to the expected columns and data types.
* **Key Detail B: The READONLY Requirement:** In most implementations (such as SQL Server), TVPs must be passed into routines with the `READONLY` keyword. This means the stored procedure cannot perform `UPDATE` or `DELETE` operations directly on the parameter; instead, it must use the data to modify target tables or stage it into a temporary table if manipulation is required.
* **The Logic:** TVPs solve the "Chatty I/O" problem. Without TVPs, developers often resort to passing comma-separated strings (requiring expensive parsing), XML/JSON blobs (requiring high CPU overhead), or executing a loop of individual insert statements (causing massive network latency). TVPs leverage the database's native set-based processing capabilities to handle bulk data efficiently.

> [!NOTE]
> While TVPs are highly efficient for small to medium data sets (typically under 1,000 rows), they do not maintain statistics like standard tables. For massive bulk loads, temporary tables or `BULK INSERT` operations may be more performant.

### 3. The Evidence
* **Context (CAR/STAR):** A financial reporting system was struggling with "Time-to-Report" metrics because the application was sending 500+ individual trade adjustments to the database one by one, causing significant lock contention and transaction log bloat.
* **Action:** I implemented a User-Defined Table Type to represent the trade adjustment schema and refactored the C# data access layer to pass a `DataTable` object as a single TVP. I then updated the backend stored procedure to use a `MERGE` statement to process the entire set in a single atomic transaction.
* **Result:** This change reduced the total execution time for bulk adjustments by 85% and eliminated the deadlocks previously caused by the high frequency of individual row locks.

> [!TIP]
> When using TVPs in .NET, ensure the `SqlParameter.SqlDbType` is explicitly set to `SqlDbType.Structured` and the `TypeName` matches the UDTT defined in your database exactly.

### 4. The Interview "Pivot"
* **Triggers:** "How do you optimize bulk data operations?", "What is the best way to pass a list of IDs to a stored procedure?", or "How do you reduce database network latency?"
* **The Connection:** This topic allows me to demonstrate my expertise in set-based logic and performance tuning. It proves I don't just write code that works, but code that scales by minimizing the overhead between the application tier and the data tier. It also shows I am familiar with database-specific features that ensure type safety and data integrity.

> [!IMPORTANT]
> Always mention that TVPs are scoped to the session/batch, meaning they are automatically cleaned up by the engine, reducing the manual management overhead associated with global temporary tables.