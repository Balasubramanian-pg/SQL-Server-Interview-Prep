# 53. Global Temp Tables

### 1. The Anchor
* **One-Sentence Pitch:** Global Temporary Tables are session-independent, transient database objects that allow data to be shared across all active connections while maintaining an automatic cleanup lifecycle based on reference counting.
* **Category:** Technical Skill / Database Engineering

### 2. The Mechanics
* **Key Detail A: Scope and Visibility:** Global temporary tables (typically denoted by a double-prefix, such as `##TableName`) are stored in the system's temporary database (e.g., `tempdb`) and are visible to every user and every process currently connected to the database instance.
* **Key Detail B: Deterministic Cleanup:** The table persists as long as the session that created it is active. Once the creating session terminates, the database engine marks the table for deletion; however, the actual drop is deferred until all other sessions currently referencing the table have finished their tasks.
* **The Logic:** This mechanism solves the "Shared Transient State" problem. In complex multi-threaded environments or distributed systems, processes often need to exchange intermediate data without the overhead of a permanent schema object. Global temp tables provide a high-performance, self-cleaning buffer that avoids the logging overhead and manual maintenance associated with standard physical tables.

> [!IMPORTANT]
> Because global temporary tables are visible to all users, naming collisions are a significant risk. Unlike local temporary tables, the system does not append a unique numeric suffix to the name to differentiate between sessions.

### 3. The Evidence
* **Context (CAR/STAR):** A financial reporting system utilized a microservices architecture where three distinct services (Validation, Enrichment, and Aggregation) needed to process a massive batch of intraday transactions simultaneously.
* **Action:** I implemented a global temporary table to serve as a centralized, high-speed staging area. The Validation service initialized the table, while the Enrichment and Aggregation services performed concurrent read/write operations against it. This replaced a legacy approach that used a permanent "Staging" table which frequently suffered from metadata contention and required complex "cleanup" scripts that often failed.
* **Result:** The implementation reduced total batch processing time by 30% due to decreased I/O overhead and eliminated 100% of the "table already exists" or "orphaned data" errors previously caused by failed manual cleanup routines.

> [!TIP]
> Use global temporary tables when you need to pass data between different database connections that cannot share a single session context, such as when using a connection pool where different steps of a business process might be handled by different physical connections.

### 4. The Interview "Pivot"
* **Triggers:** Questions regarding "Session vs. Global scope," "Handling concurrency in SQL," "Optimizing tempdb usage," or "How to share data between two different stored procedure calls running in parallel."
* **The Connection:** This topic allows me to demonstrate a sophisticated understanding of database internals and concurrency. It proves I can design architectures that balance the need for shared data access with the necessity of automated resource management, ensuring that the system remains performant and free of "dead" data.

> [!WARNING]
> Always ensure that permissions are correctly configured. In many environments, any user can drop a global temporary table if they have the appropriate permissions in the temporary database, which can lead to stability issues if not managed via service accounts.