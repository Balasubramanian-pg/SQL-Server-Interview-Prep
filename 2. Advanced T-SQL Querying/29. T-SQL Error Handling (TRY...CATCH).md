# 29. T SQL Error Handling (TRY...CATCH)

### 1. The Anchor
* **One-Sentence Pitch:** TRY...CATCH is a structured exception-handling mechanism in T-SQL that allows developers to intercept runtime errors, manage transactions safely, and implement robust logging without terminating the entire batch execution.
* **Category:** Technical Skill / Database Development

### 2. The Mechanics
* **Key Detail A: The Block Structure:** Code is divided into two distinct segments: the `BEGIN TRY...END TRY` block, which contains the operational logic, and the `BEGIN CATCH...END CATCH` block, which executes only if an error with a severity greater than 10 (that does not terminate the database connection) occurs.
* **Key Detail B: Error Introspection Functions:** Within the CATCH block, T-SQL provides a suite of system functions—`ERROR_NUMBER()`, `ERROR_MESSAGE()`, `ERROR_SEVERITY()`, `ERROR_STATE()`, `ERROR_LINE()`, and `ERROR_PROCEDURE()`—to capture the exact context of the failure for debugging and auditing.
* **The Logic: Transactional Integrity:** The primary purpose is to prevent "orphaned transactions." In complex operations, an error might stop execution but leave a transaction open. TRY...CATCH allows the developer to use `XACT_STATE()` to programmatically decide whether to `COMMIT` or `ROLLBACK` based on the error's impact on the transaction's validity.

> [!IMPORTANT]
> Not all errors are caught by TRY...CATCH. Compilation errors, statement-level recompile errors, and high-severity errors (severity 20 or higher) that terminate the connection will bypass the CATCH block.

### 3. The Evidence
* **Context (CAR/STAR):** A financial reporting system was experiencing intermittent "zombie transactions" where deadlocks during peak hours caused subsequent processes to hang, leading to data inconsistency and manual database locks.
* **Action:** I refactored the core ETL stored procedures to use a standardized TRY...CATCH pattern. I implemented a logic gate using `IF (XACT_STATE()) = -1 ROLLBACK TRANSACTION;` to ensure uncommittable transactions were immediately cleared, and integrated a custom `usp_LogError` procedure to persist error metadata into a dedicated audit table.
* **Result:** This implementation eliminated manual lock-clearing interventions, reduced the mean time to resolution (MTTR) for production bugs by 60% due to detailed error logging, and ensured 100% transactional atomicity.

> [!TIP]
> Always use `SET XACT_ABORT ON` in conjunction with TRY...CATCH to ensure that the transaction is automatically aborted if a run-time error occurs, providing an extra layer of safety for data integrity.

### 4. The Interview "Pivot"
* **Triggers:** "How do you ensure your database code is production-ready?", "Describe your approach to transaction management," or "What happens when a stored procedure fails mid-execution?"
* **The Connection:** This topic proves that I don't just write code that works in "happy path" scenarios; I design resilient systems that anticipate failure. It demonstrates my understanding of the SQL Server engine's internal behavior and my commitment to maintaining data integrity in high-concurrency environments.

> [!WARNING]
> Be careful when nesting TRY...CATCH blocks. An error in a CATCH block will jump to the next outer CATCH block, if one exists. If not, the error will be returned to the calling application, potentially leaving transactions in an indeterminate state if not handled at the top level.