# 10. UNBOUNDED PRECEDING and FOLLOWING

### 1. The Anchor
* **One-Sentence Pitch:** UNBOUNDED PRECEDING and FOLLOWING are window frame boundary keywords in SQL that define the absolute start or absolute end of a partition, enabling calculations across the entire data subset regardless of the current row's position.
* **Category:** Technical Skill / SQL Development & Data Analysis

### 2. The Mechanics
* **Key Detail A: UNBOUNDED PRECEDING:** This keyword sets the start of the window frame to the very first row within the current partition. It is most commonly paired with `CURRENT ROW` to create "running" or "cumulative" calculations, such as year-to-date totals or moving averages that include all historical data up to the present point.
* **Key Detail B: UNBOUNDED FOLLOWING:** This keyword sets the end of the window frame to the very last row within the current partition. When used in conjunction with `UNBOUNDED PRECEDING`, it allows a window function to access every row in the partition simultaneously, effectively allowing you to compare a specific row's value against a partition-wide aggregate without using a `GROUP BY` clause or a self-join.
* **The Logic:** These keywords solve the problem of "frame flexibility." While standard aggregates collapse rows, window functions with unbounded boundaries preserve row-level detail while providing access to the full context of the dataset. This is essential for calculating percentages of totals, identifying the first or last record in a sequence, or performing look-ahead analysis.

> [!IMPORTANT]
> In many SQL dialects, if you define an `ORDER BY` clause within a window function but omit the frame specification, the default frame is `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`.

### 3. The Evidence
* **Context (CAR/STAR):** A retail client needed a dashboard that displayed daily sales alongside two specific metrics: the cumulative sales for the month and the percentage contribution of that day's sales to the total monthly forecast.
* **Action:** I utilized `SUM(sales) OVER (PARTITION BY month ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)` to generate the running total. To calculate the percentage of the total, I used `SUM(sales) OVER (PARTITION BY month ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)` as the denominator in the calculation.
* **Result:** This approach eliminated the need for multiple subqueries and temporary tables, reducing the query execution time by 60% and providing a clean, readable codebase for the client's BI team.

> [!TIP]
> Use `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` when you need to find the `FIRST_VALUE` or `LAST_VALUE` across an entire sorted partition to ensure the window doesn't shrink based on the current row's position.

### 4. The Interview "Pivot"
* **Triggers:** "How do you handle running totals in SQL?", "Explain the difference between a window function and a GROUP BY," or "How would you optimize a query that uses multiple self-joins for aggregation?"
* **The Connection:** This topic proves my ability to write high-performance, analytical SQL. It demonstrates that I understand how to manipulate data frames to solve complex business logic—like cohort analysis or financial reporting—directly within the database layer, ensuring scalability and efficiency in data pipelines.

> [!WARNING]
> Be mindful of memory usage when using `UNBOUNDED` frames on extremely large partitions (millions of rows), as the database must maintain the frame context in memory to perform the calculation.