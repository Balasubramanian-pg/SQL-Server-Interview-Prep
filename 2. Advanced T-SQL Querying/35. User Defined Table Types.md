# 35. User Defined Table Types

### 1. The Anchor
* **One-Sentence Pitch:** User-Defined Table Types (UDTTs) are custom, reusable schema objects that define a table structure, enabling the passing of entire multi-row datasets into stored procedures and functions as a single parameter.
* **Category:** Technical Skill / Database Architecture

### 2. The Mechanics
* **Key Detail A: Schema Encapsulation:** A UDTT acts as a blueprint for data. It defines columns, data types, nullability, and even constraints (such as Primary Keys or Unique constraints) at the database level. Once defined, it can be instantiated as a table variable within scripts or used as a parameter type in routines.
* **Key Detail B: The READONLY Requirement:** When passing a UDTT as a parameter to a stored procedure or function, it must be declared with the `READONLY` keyword. This prevents the routine from modifying the data within the input set, ensuring the integrity of the calling scope's data and allowing the database engine to optimize the execution plan.
* **The Logic:** UDTTs solve the "N+1" problem and reduce network latency. Without UDTTs, developers often resort to passing comma-separated strings, XML blobs, or making multiple individual calls to the database. UDTTs allow the application to send a structured collection in a single round-trip, aligning the application's object-oriented collections with the database's set-based logic.

> [!NOTE]
> While UDTTs are highly efficient for passing data, they do not support the creation of non-inline indexes after the type is defined. All necessary indexes must be defined within the `CREATE TYPE` statement itself.

### 3. The Evidence
* **Context (CAR/STAR):** A financial reporting system was struggling with a "Bulk Update" feature where users could modify thousands of transaction statuses simultaneously. The existing implementation used a loop in the application code, calling an `UpdateTransaction` stored procedure for every single row, leading to significant locking and timeouts.
* **Action:** I designed a User-Defined Table Type that matched the transaction update schema (TransactionID and NewStatus). I refactored the backend to batch these updates into a single call, passing the entire collection as a UDTT parameter to a new stored procedure that performed a single `JOIN` update.
* **Result:** This transition reduced the total execution time for a 5,000-row update from 45 seconds to under 2 seconds. It also eliminated the deadlocks previously caused by the high frequency of individual row locks.

> [!TIP]
> When using UDTTs with .NET applications, utilize the `SqlDbType.Structured` parameter type and map your `List<T>` or `DataTable` directly to the UDTT for seamless integration.

### 4. The Interview "Pivot"
* **Triggers:** "How do you handle bulk data uploads?", "What are the best practices for passing lists to SQL Server?", or "How do you optimize database round-trips?"
* **The Connection:** This topic allows me to demonstrate my expertise in set-based processing. By discussing UDTTs, I show that I don't just write queries that work; I design database interfaces that are performant, maintainable, and optimized for high-concurrency environments. It proves I understand the cost of network latency and the importance of minimizing context switching between the application and the database.

> [!IMPORTANT]
> Always mention that UDTTs are preferred over XML or JSON parsing within SQL Server when the schema is known and static, as they provide better type safety and lower CPU overhead for shredding data.