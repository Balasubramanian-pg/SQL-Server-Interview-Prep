# 1. 8KB Page Structure

Canonical documentation for [1. 8KB Page Structure](1. Database Architecture Internals/1. 8KB Page Structure.md). This document defines concepts, terminology, and standard usage.

## Purpose
The 8KB page structure exists to provide a fixed-size, predictable unit of data management for persistent storage systems and memory-resident buffers. By discretizing data into uniform 8,192-byte blocks, systems can optimize I/O operations, simplify memory allocation, and establish a consistent framework for addressing data via pointers and offsets. This structure addresses the need for efficient data retrieval, concurrency control at the page level, and the physical organization of logical records.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural principles of 8KB paging rather than specific database engine internals.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Logical and physical layout of an 8KB page.
> * Header, payload, and footer (slot array) mechanics.
> * Data alignment and offset management.
> * The relationship between pages and extents/blocks.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., SQL Server vs. PostgreSQL specific byte-offsets).
> * Hardware-level sector sizing (e.g., 4K Advanced Format drives).
> * Compression algorithms applied to page contents.

## Definitions
| Term | Definition |
|------|------------|
| Page | The fundamental unit of data storage, exactly 8,192 bytes in size. |
| Header | A fixed-size metadata section at the beginning of the page containing structural information. |
| Slot Array | A collection of pointers (offsets) located at the end of the page, used to locate records within the payload. |
| Payload | The contiguous space between the header and the slot array where actual data records are stored. |
| Free Space | The unallocated gap between the end of the last record and the beginning of the slot array. |
| Row Offset | A numerical value representing the distance in bytes from the start of the page to the start of a specific record. |

## Core Concepts
The 8KB page structure is built on the principle of **Atomic I/O**. Because the operating system and storage controllers handle data in blocks, the 8KB size serves as a bridge between the logical row and the physical disk sector.

**The Sandwich Architecture**
The page is organized like a sandwich. Metadata is stored at the absolute beginning (Header), and the index of contents is stored at the absolute end (Slot Array). The data itself occupies the middle. This allows the data and the index to grow toward each other.

> [!TIP]
> Think of a page like a physical ledger book page. The header is the page number and date, the lines are the data rows, and the footer is the index or "table of contents" for that specific page, telling you exactly where each entry starts.

**Fixed-Size Constraints**
Every page is exactly 8,192 bytes. This consistency allows the system to calculate the physical location of any page in a file using simple multiplication: `File Offset = Page ID * 8192`.

## Standard Model
The standard model for an 8KB page consists of three primary contiguous regions:

1.  **Page Header (Top):** Typically occupies 64 to 128 bytes. It contains the Page ID, pointers to the next/previous pages (for linked lists), the amount of free space available, and the number of slots in the slot array.
2.  **Data Payload (Middle):** Records are inserted starting immediately after the header. Records are usually stored contiguously to minimize internal fragmentation.
3.  **Slot Array / Offset Table (Bottom):** This grows backwards from the very end of the 8,192nd byte. Each entry (slot) is usually a 2-byte integer pointing to the starting byte of a record in the payload.

> [!IMPORTANT]
> The "Free Space" in a page is not just any empty area; it is specifically the gap between the end of the data payload and the start of the slot array. When this gap is smaller than the required record size, the page is considered full.

## Common Patterns
*   **Forward Growth:** Records are added from the top down, while the slot array grows from the bottom up. This maximizes the utility of the 8KB space.
*   **Page Linking:** Pages often contain "Next Page" and "Previous Page" pointers in their headers to form a doubly-linked list, allowing for ordered scans.
*   **Ghost Records:** When a record is deleted, it is often marked as a "ghost" in the header or record metadata rather than being physically erased immediately. This facilitates faster rollbacks and concurrency.

## Anti-Patterns
*   **Row Chaining (Over-provisioning):** Attempting to store a record larger than 8,060 bytes (8KB minus header/footer) forces the system to "chain" the data across multiple pages, significantly degrading I/O performance.
*   **Internal Fragmentation:** Leaving large gaps between records within the payload. This usually occurs when records are updated to a smaller size and the space is not reclaimed (compacted).
*   **Low Fill Factor:** Purposely leaving too much free space on every page. While this reduces page splits, it increases the memory footprint and requires more I/O to read the same amount of data.

> [!CAUTION]
> Avoid designs where the slot array is stored in the header. This creates a "hard ceiling" for the number of records per page and limits flexibility for variable-length data.

## Edge Cases
*   **Null Bitmaps:** If a record contains many nullable columns, a "null bitmap" is often stored within the record or the page to indicate which values are missing, preventing the need to store empty bytes.
*   **Page Corruption:** If a system crash occurs during a write, a "torn page" may result where only part of the 8KB was written to disk. Systems use checksums in the header to detect this.
*   **Overflow Data:** For extremely large variable-length strings (BLOBs), the 8KB page may only store a 24-byte pointer to an "Overflow Page," which does not follow the standard row-store structure.

## Related Topics
*   **Extent Management:** How groups of eight 8KB pages are managed as a single unit.
*   **Buffer Pool Management:** The mechanism for caching 8KB pages in RAM.
*   **B-Tree Indexing:** The logical structure that organizes these pages into a searchable hierarchy.
*   **Write-Ahead Logging (WAL):** How changes to 8KB pages are recorded for durability.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |