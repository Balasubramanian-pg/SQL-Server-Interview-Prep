# 43. System Base Tables

Canonical documentation for [43. System Base Tables](1. Database Architecture Internals/43. System Base Tables.md). This document defines concepts, terminology, and standard usage.

## Purpose
System Base Tables serve as the foundational persistence layer for a database management system's (DBMS) metadata. They are the underlying physical structures that store the "data about the data"â€”including definitions of tables, columns, indexes, constraints, security permissions, and configuration parameters.

The primary purpose of these tables is to provide a structured, queryable, and durable repository that the database engine uses to manage its internal state and enforce the rules of the relational model. Without system base tables, a database engine would have no memory of its own schema or operational requirements between restarts.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural necessity of metadata persistence rather than specific vendor syntax.

## Scope
This documentation covers the theoretical and functional requirements of the lowest-level metadata storage within a data system.

> [!IMPORTANT]
> **In scope:**
> * Persistence of schema definitions and object metadata.
> * The relationship between the database engine and its internal catalog.
> * Integrity requirements for system-level data.
> * The distinction between base tables and abstraction layers (views).

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., PostgreSQL's `pg_catalog`, SQL Server's `sys` base tables, or Oracle's Data Dictionary).
> * Physical storage formats (e.g., B-trees vs. Heap files) used by specific engines.
> * User-defined application tables.

## Definitions
| Term | Definition |
|------|------------|
| Metadata | Data that describes the structure, constraints, and properties of other data. |
| System Catalog | The complete collection of system base tables and views that define the database. |
| Data Dictionary | A centralized repository of information about data such as meaning, relationships to other data, origin, usage, and format. |
| Bootstrapping | The process by which a database engine reads its own base tables to initialize its internal structures during startup. |
| DDL (Data Definition Language) | The subset of commands (e.g., CREATE, ALTER, DROP) that modify the records within system base tables. |

## Core Concepts

### The Self-Describing Nature of Databases
A modern database system is self-describing. This means the engine uses the same mechanisms to store information about the system as it does to store user data. System base tables are the physical manifestation of this principle.

### Metadata Persistence
Unlike volatile memory structures, system base tables are stored on non-volatile media. This ensures that when a database is shut down and restarted, the engine can reconstruct the entire environment (users, tables, indexes) by reading these tables.

### The Abstraction Barrier
In a well-architected system, users and applications never interact with system base tables directly. Instead, they interact with "System Views" or "Information Schemas." This abstraction allows the database vendor to change the underlying physical structure of the base tables without breaking user queries or administrative scripts.

> [!TIP]
> Think of system base tables as the "DNA" of the database. While you observe the "organism" (the database behavior and views), the base tables contain the fundamental code that dictates how that organism is built and functions.

## Standard Model
The standard model for system base tables follows a hierarchical or relational structure that mirrors the database's logical components:

1.  **The Root (Global) Level:** Tables that store information applicable to the entire instance, such as user accounts, roles, and global configuration settings.
2.  **The Container (Database) Level:** Tables that define specific databases or namespaces within the instance.
3.  **The Object Level:** Tables that define individual entities like tables, views, stored procedures, and triggers.
4.  **The Attribute Level:** Tables that define the properties of objects, such as column names, data types, and default values.
5.  **The Constraint/Relationship Level:** Tables that define how objects relate to one another (Foreign Keys) and the rules they must follow (Check Constraints, Unique Constraints).

## Common Patterns

### The "Table of Tables"
Almost every system implements a core base table that assigns a unique internal identifier (OID or GUID) to every object in the system. This identifier is then used as a foreign key in other system tables to link columns, indexes, and permissions to the correct object.

### Versioning and Evolution
As database engines are upgraded, the schema of system base tables often changes. A common pattern is the inclusion of a "version" or "compatibility" table that the engine checks during startup to determine if a metadata migration is required.

### Dependency Tracking
System base tables often include a dedicated "dependency" table. This tracks which objects rely on others (e.g., which view relies on which table), allowing the engine to prevent the deletion of objects that would leave the system in an inconsistent state.

## Anti-Patterns

### Direct Manipulation
The most significant anti-pattern is the direct execution of `INSERT`, `UPDATE`, or `DELETE` statements against system base tables by a user.

> [!CAUTION]
> Direct modification of system base tables can lead to catastrophic metadata corruption, rendering the entire database unreadable or unbootable. Always use DDL commands or provided administrative APIs.

### Hard-Coding Metadata References
Relying on the specific physical structure or column names of system base tables in application code is an anti-pattern. Because these tables are implementation-specific and subject to change during engine updates, applications should use standardized views (like `INFORMATION_SCHEMA`).

## Edge Cases

### The Bootstrapping Paradox
The database engine needs to read system base tables to know how to read tables. To solve this "chicken and egg" problem, most engines have a "hard-coded" or "static" definition of the most fundamental system tables (the "meta-metadata") embedded directly in the engine's binary code.

### Metadata Bloat
In systems with extremely high churn of temporary objects (e.g., creating and dropping thousands of tables per hour), system base tables can suffer from fragmentation and bloat, similar to user tables. This can lead to performance degradation of the entire system as DDL operations slow down.

### Circular Dependencies
While rare, it is theoretically possible to define metadata that creates a circular dependency (e.g., a rule in a system table that depends on a function defined in another system table). Database engines must implement specific logic to break these cycles during the bootstrapping phase.

## Related Topics
*   **Information Schema:** The standardized, read-only views providing access to metadata.
*   **Data Definition Language (DDL):** The commands used to indirectly modify system base tables.
*   **Database Catalogs:** The logical grouping of system metadata.
*   **Transaction Logs:** How changes to system base tables are recorded to ensure atomicity.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |