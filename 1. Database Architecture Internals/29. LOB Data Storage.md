# 29. LOB Data Storage

Canonical documentation for [29. LOB Data Storage](1. Database Architecture Internals/29. LOB Data Storage.md). This document defines concepts, terminology, and standard usage.

## Purpose
LOB (Large Object) Data Storage exists to manage data entities that exceed the standard storage capacity of a database's primary data pages or row-size limits. While traditional relational data types (integers, dates, short strings) are optimized for high-speed indexing and fixed-width retrieval, LOB storage is designed to handle massive, unstructured, or semi-structured payloads such as high-resolution images, video files, large XML/JSON documents, and long-form text.

The primary problem space addressed by LOB storage is the decoupling of metadata from heavy payloads. By segregating large data from the primary row structure, systems can maintain high performance for standard queries while still providing a mechanism to retrieve large-scale content when necessary.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural principles of large object management rather than specific database engine syntax.

## Scope
The scope of this documentation covers the architectural strategies for persisting, referencing, and retrieving large data objects within a structured data environment.

> [!IMPORTANT]
> **In scope:**
> * Storage mechanisms (Inline vs. Out-of-line).
> * Data integrity and consistency models for large payloads.
> * Memory management and streaming protocols.
> * Fragmentation and space reclamation strategies.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., Oracle BLOB vs. SQL Server FILESTREAM).
> * File system-only storage without database integration.
> * Network-level data transfer protocols (e.g., FTP/SFTP).

## Definitions
| Term | Definition |
|------|------------|
| LOB | Large Object; a data type designed to store large amounts of data as a single entity. |
| BLOB | Binary Large Object; a collection of binary data stored as a single entity (e.g., images, compiled code). |
| CLOB | Character Large Object; a collection of character data (text) stored as a single entity. |
| NCLOB | National Character Large Object; a CLOB that supports multi-byte national character sets (e.g., Unicode). |
| Inline Storage | Storing the LOB data directly within the data row on the primary data page. |
| Out-of-line Storage | Storing the LOB data in a separate storage area, leaving only a pointer in the primary row. |
| LOB Locator | A pointer or reference stored in the database row that identifies the location of the actual LOB data. |
| Chunking | The process of breaking a LOB into smaller segments for easier management and streaming. |

## Core Concepts

### The Storage Dichotomy
LOB storage is fundamentally divided between the **metadata** (the row containing the reference) and the **payload** (the actual large object). Because data pages in most systems have a fixed size (e.g., 8KB or 16KB), a LOB that exceeds this size cannot be stored using standard row-storage logic.

### Inline vs. Out-of-line Storage
*   **Inline Storage:** Small LOBs are often stored directly in the row to avoid the overhead of a second lookup. This is efficient for data that is only slightly larger than standard types.
*   **Out-of-line Storage:** When a LOB exceeds a defined threshold, the system moves the data to a separate segment (a LOB storage area). The original row retains a "Locator" or "Pointer."

> [!TIP]
> Think of Inline storage like a small note written directly in a ledger, while Out-of-line storage is like a reference in the ledger pointing to a specific box in a warehouse.

### Page Chaining and B-Trees
To manage LOBs that span multiple megabytes or gigabytes, systems use page chaining or specialized B-tree structures. This allows the system to jump to specific offsets within a LOB without reading the entire object into memory, which is critical for "random access" within a large file.

## Standard Model
The standard model for LOB storage follows a tiered approach:

1.  **Threshold Evaluation:** Upon insertion, the system checks the size of the LOB.
2.  **Storage Assignment:**
    *   If size < `Threshold`, store **Inline**.
    *   If size > `Threshold`, store **Out-of-line**.
3.  **Locator Generation:** For out-of-line data, a unique locator is generated and embedded in the primary table row.
4.  **Segment Allocation:** The payload is written to a dedicated LOB segment, potentially across multiple non-contiguous pages.
5.  **Consistency Management:** The system ensures that the LOB data and the primary row are subject to the same transactional ACID properties.

## Common Patterns

### Lazy Loading
Applications retrieve the primary row first and only fetch the LOB payload if specifically requested. This prevents network congestion and memory exhaustion during bulk data fetches.

### Streaming
Rather than loading a 2GB BLOB into application memory, the system provides a stream interface. The application reads the LOB in small chunks (e.g., 64KB), processes them, and moves to the next chunk.

### Deduplication
In systems where the same large file (e.g., a corporate logo) is stored multiple times, the storage engine may store only one physical copy of the LOB and point multiple locators to that single physical address.

## Anti-Patterns

### Over-Indexing LOB Columns
Attempting to create standard indexes on LOB columns is generally impossible or highly inefficient. 

> [!CAUTION]
> Avoid including LOB columns in `SELECT *` queries during high-frequency operations. This can lead to massive I/O overhead and "buffer pool pollution," where large, rarely-used LOB data displaces frequently-used index data in memory.

### Frequent Updates to Large LOBs
LOBs are typically optimized for "Write Once, Read Many" (WORM). Frequent updates or small appends to a large LOB can cause massive fragmentation and generate excessive transaction log volume, as many systems rewrite the entire LOB for even minor changes.

## Edge Cases

### Zero-Byte LOBs vs. NULL
A LOB can be `NULL` (the locator does not exist) or it can be an empty LOB (the locator exists, but the payload is zero bytes). These are handled differently by storage engines and can affect application logic.

### Character Set Conversion
For CLOBs, moving data between systems with different character encodings (e.g., UTF-8 to UTF-16) can change the byte-size of the LOB, potentially pushing an "Inline" LOB to "Out-of-line" storage during a migration or update.

### Partial Updates
Some advanced storage models support "piece-wise" updates, allowing a user to change bytes 500-600 of a 1GB BLOB without rewriting the other 999MB. However, this is not universal and often requires specific API calls.

## Related Topics
*   **2. Data Types:** The fundamental classification of data.
*   **15. Indexing Strategies:** How pointers and locators interact with search structures.
*   **42. Transaction Logging:** How large changes are recorded for recovery.
*   **55. Compression Algorithms:** Techniques for reducing the physical footprint of LOBs.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |