# 49. Database Snapshots (Sparse Files)

Canonical documentation for [49. Database Snapshots (Sparse Files)](1. Database Architecture Internals/49. Database Snapshots (Sparse Files).md). This document defines concepts, terminology, and standard usage.

## Purpose
Database snapshots provide a point-in-time, read-only view of a source database. This mechanism allows for the creation of a static image of data without the overhead of a full physical copy. The primary problem space addressed is the need for consistent reporting, historical data auditing, and a "safety net" for administrative operations without consuming the equivalent storage space of the original database.

By utilizing sparse files, the system ensures that storage is only consumed when changes occur in the source database, making the process significantly more efficient than traditional backups for short-term use cases.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the underlying logic of Copy-on-Write (CoW) and sparse file allocation.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The mechanism of Copy-on-Write (CoW) as applied to database snapshots.
> * The behavior and structure of sparse files within the file system.
> * Lifecycle management of snapshots (creation, divergence, and deletion).
> * Performance implications of snapshot maintenance on the source database.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific syntax or proprietary command-line tools.
> * Hardware-level storage snapshots (LUN snapshots) that occur below the file system layer.
> * Traditional full, differential, or incremental backup streaming.

## Definitions
| Term | Definition |
|------|------------|
| Snapshot | A read-only, static view of a database at a specific moment in time. |
| Sparse File | A type of computer file that attempts to use file system space more efficiently by not writing empty blocks to disk. |
| Source Database | The active, read-write database from which a snapshot is derived. |
| Copy-on-Write (CoW) | A resource management technique where the original data is copied to a snapshot file only when a modification is first attempted on the source. |
| Side-Page File | The physical file on disk that stores the original data pages for the snapshot as they are displaced from the source. |
| Allocation Unit | The smallest block of logical disk space that can be allocated to hold a file. |

## Core Concepts

### The Sparse File Mechanism
A sparse file is a file that contains "holes"â€”large sections of zeroed data that do not occupy physical space on the storage medium. In the context of database snapshots, the snapshot file is initialized as a sparse file. Initially, it contains no user data and occupies negligible disk space.

### Copy-on-Write (CoW) Logic
The snapshot does not store a copy of the entire database. Instead, it maintains a pointer to the source. When a data page in the source database is modified for the first time after snapshot creation:
1. The original (unmodified) page is read from the source.
2. The original page is written to the sparse file (the snapshot).
3. The new, modified page is written to the source database.

> [!TIP]
> Think of a snapshot as a "transparent overlay." When you look through the snapshot, you see the source database. If a piece of the source changes, the "old" version is caught by the overlay, so your view through the overlay never changes.

### Point-in-Time Consistency
Because the snapshot preserves the state of every data page at the exact moment of creation, it provides transactional consistency. Any transactions that were in progress at the time of the snapshot are rolled back in the snapshot view to ensure a stable, committed state of data.

## Standard Model

The standard model for database snapshots follows a specific lifecycle:

1.  **Initialization:** The system creates a sparse file and generates a bitmap to track which pages have been moved to the snapshot.
2.  **Read Operations:** When a user queries the snapshot:
    *   If the requested page has not changed in the source, the system reads directly from the source database.
    *   If the page has changed, the system reads from the sparse file.
3.  **Write Operations (Source):** The source database continues to accept writes. The first time any page is modified, the CoW process triggers. Subsequent writes to the same page do not trigger further copies to the snapshot.
4.  **Deletion:** When the snapshot is deleted, the sparse file is removed, and the overhead on the source database's write operations is eliminated.

> [!IMPORTANT]
> Snapshots are inherently read-only. Any attempt to modify data within a snapshot violates the standard model of point-in-time integrity.

## Common Patterns

*   **Reporting Offload:** Running heavy analytical queries against a snapshot to avoid locking contention on the primary production database.
*   **Pre-Maintenance Safeguard:** Creating a snapshot immediately before a risky schema change or bulk data import. If the operation fails, the database can be "reverted" to the snapshot state.
*   **Development/Test Refresh:** Providing developers with a static view of production data for debugging without the time and space requirements of a full restore.
*   **Historical Auditing:** Maintaining a series of snapshots (e.g., end-of-day) for short-term comparison of data changes.

## Anti-Patterns

*   **Long-Term Retention:** Keeping snapshots for weeks or months. As the source database changes, the sparse file grows, and the performance penalty on the source persists.
*   **Using Snapshots as Backups:** Snapshots depend on the source database's health. If the source files are lost or corrupted, the snapshot is rendered useless.
*   **High-Churn Environments:** Creating snapshots on databases with extremely high write volume. This leads to rapid sparse file growth and significant I/O overhead.
*   **Chained Snapshots:** Creating snapshots of snapshots (where supported), which can lead to complex dependency trees and severe latency.

> [!CAUTION]
> Never assume a snapshot is a substitute for a redundant, off-site backup. A snapshot is a local pointer-based mechanism, not a physical data redundancy strategy.

## Edge Cases

*   **Disk Space Exhaustion:** Sparse files grow as the source database changes. If the disk hosting the sparse file runs out of space, the snapshot becomes suspect or offline, and in some implementations, the source database may experience errors.
*   **File System Fragmentation:** Because sparse files are written to incrementally as pages change in the source, they can become highly fragmented over time, leading to degraded read performance.
*   **Sparse File Awareness:** Some file-copying utilities are not "sparse-aware." Copying a 100GB sparse file that only contains 1GB of data might result in a 100GB physical file on the destination, losing the space-saving benefits.
*   **Metadata Overhead:** While the data pages are handled via CoW, the metadata tracking (the map of what is in the snapshot vs. the source) requires memory and CPU cycles for every write operation on the source.

## Related Topics

*   **ACID Properties:** The fundamental database principles that snapshots must uphold.
*   **Write-Ahead Logging (WAL):** The mechanism often used in conjunction with snapshots to ensure transactional integrity.
*   **Copy-on-Write (CoW) File Systems:** File systems (like ZFS or Btrfs) that implement snapshotting at the block level rather than the database level.
*   **Database Mirroring/Replication:** Alternative methods for maintaining secondary copies of data.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |