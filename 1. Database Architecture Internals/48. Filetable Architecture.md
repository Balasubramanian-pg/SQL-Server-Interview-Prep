# 48. Filetable Architecture

Canonical documentation for [48. Filetable Architecture](1. Database Architecture Internals/48. Filetable Architecture.md). This document defines concepts, terminology, and standard usage.

## Purpose
The Filetable Architecture exists to resolve the historical tension between unstructured file system storage and structured relational database management. Traditionally, applications had to choose between storing files in a database (ensuring transactional integrity but sacrificing performance and ease of access) or storing them in a file system (ensuring high performance and compatibility with standard tools but losing synchronization with database records).

Filetable Architecture provides a hybrid storage abstraction. It allows an application to store files and folders in specialized tables within a database while making that data accessible through the standard file system APIs of the operating system. This architecture ensures that the file system and the database share a single source of truth for both the file content and its associated metadata.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural bridge between relational schemas and hierarchical file systems.

## Scope
The scope of this document covers the structural requirements, synchronization logic, and access patterns inherent in a Filetable system.

> [!IMPORTANT]
> **In scope:**
> * The mapping of hierarchical file structures to relational table rows.
> * Transactional consistency between I/O operations and database state.
> * Metadata synchronization and attribute mapping.
> * Namespace management within a relational context.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., Microsoft SQL Server FileTables).
> * Operating system-specific driver development (e.g., filter drivers or FUSE).
> * Hardware-level storage optimization or RAID configurations.

## Definitions
| Term | Definition |
|------|------------|
| **Filetable** | A specialized database table with a fixed schema that represents a directory hierarchy and its contained files. |
| **Namespace** | The logical hierarchy of files and folders, typically represented as a URI or UNC path, managed by the database. |
| **Blob Stream** | The actual binary content of a file, stored as a Large Object (LOB) but accessible via streaming I/O. |
| **Path Locator** | A unique identifier (often hierarchical) that determines the position of a file or directory within the Filetable tree. |
| **Attribute Mapping** | The correlation between file system attributes (Created Date, Read-Only, Hidden) and database columns. |
| **I/O Interceptor** | A mechanism that captures file system requests and translates them into database operations. |

## Core Concepts

### The Dual-Access Model
The fundamental concept of Filetable Architecture is the ability to access the same data through two distinct interfaces:
1.  **The SQL Interface:** Standard DML (Data Manipulation Language) operations (INSERT, UPDATE, DELETE) allow for bulk management and complex querying of file metadata.
2.  **The File System Interface:** Standard I/O APIs (Open, Read, Write, Close) allow legacy applications and OS tools to interact with the database content as if it were a local disk drive.

### Hierarchical Representation in Flat Tables
While relational tables are inherently flat, Filetable Architecture uses a "Path Locator" or "HierarchyID" to represent the parent-child relationships of a file system. Every row in a Filetable represents either a file or a directory. The architecture ensures that moving a folder in the file system is reflected as a single metadata update in the database, maintaining the integrity of all child paths.

> [!TIP]
> Think of a Filetable as a "Database-as-a-FileSystem." It acts as a translator that turns a `SELECT` statement into a directory listing and a `File.Write()` operation into a `COMMIT`.

### Transactional Integrity
Unlike traditional external file storage (where a database record might point to a file that has been deleted), Filetable Architecture ensures that the file and the record are the same entity. If a database transaction fails, the corresponding file system change is rolled back.

## Standard Model
The standard model for Filetable Architecture consists of three primary layers:

1.  **The Storage Layer:** The physical storage of binary data (Blobs) and metadata (Attributes). This layer is managed by the Database Management System (DBMS).
2.  **The Abstraction Layer:** A specialized schema within the database that enforces the file system rules (e.g., preventing duplicate filenames in the same directory, managing system attributes).
3.  **The Presentation Layer (Virtual File System):** A driver or service that exposes the database's internal Filetable as a network share or a mounted volume. This layer translates UNC paths into database queries.

## Common Patterns

### Document Management Systems (DMS)
Filetables are frequently used in DMS to allow users to drag and drop files into a network folder while the system automatically indexes the content and associates it with business entities (like invoices or employee records) via SQL joins.

### Media Asset Management
Storing high-resolution assets in a Filetable allows creative tools (which require file-handle access) to work directly with the files, while the database handles versioning, permissions, and metadata tagging.

### Staging and ETL
Using a Filetable as an "Inbound" folder where external systems drop files. The database can use triggers on the Filetable to immediately process new files as they arrive.

## Anti-Patterns

### High-Frequency Small I/O
Using a Filetable for applications that perform thousands of tiny, rapid-fire writes (such as log files or temporary cache files) is discouraged. The overhead of database transaction logging for every small I/O operation can lead to significant latency.

### Circular Metadata Dependencies
Storing metadata in the Filetable that is derived from the file content, which then triggers an update to the file content itself. This can lead to infinite loops or deadlocks within the I/O interceptor.

> [!CAUTION]
> Avoid using Filetables as a primary target for high-velocity database backups or transaction log exports. The recursive nature of managing backup files within a managed table can lead to resource exhaustion.

## Edge Cases

### Deep Path Limits
Most file systems have a maximum path length (e.g., 260 characters). A Filetable might support much deeper hierarchies internally than the presentation layer can expose to the operating system, leading to "Path Not Found" errors in the file system despite the data being present in the database.

### Filename Normalization
Different operating systems handle case sensitivity and Unicode normalization differently. A Filetable architecture must define whether "File.txt" and "file.txt" are distinct entities, especially when the database collation and the file system driver have conflicting rules.

### Bulk Import Synchronization
When millions of files are moved into a Filetable via SQL commands, the virtual file system layer may experience a "cache storm" or delay in refreshing the directory structure for connected clients.

## Related Topics
*   **BLOB (Binary Large Object) Storage:** The underlying technology for storing file content.
*   **Transactional File Systems:** The theoretical basis for atomic file operations.
*   **Unstructured Data Management:** The broader discipline of managing non-tabular data.
*   **Virtual File Systems (VFS):** The mechanism used to mount databases as drives.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |