# 32. Delta Stores

Canonical documentation for [32. Delta Stores](1. Database Architecture Internals/32. Delta Stores.md). This document defines concepts, terminology, and standard usage.

## Purpose
Delta Stores exist to resolve the fundamental tension between write-heavy workloads and read-optimized storage formats. In modern data architecture, high-performance analytical storage (such as columnar formats) is typically immutable or expensive to modify. Delta Stores provide a transient or auxiliary staging area where incremental changes—inserts, updates, and deletes—are captured in real-time or near-real-time without requiring an immediate rewrite of the primary data files.

By decoupling the ingestion of changes from the optimization of the permanent data store, Delta Stores enable high-velocity data entry while preserving the efficiency of downstream analytical queries.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural pattern rather than specific software products.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Architectural patterns for differential storage.
> * Mechanics of merging delta records with base data.
> * Lifecycle management of delta records (compaction and vacuuming).
> * Consistency models in hybrid storage environments.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., Databricks Delta Lake, Apache Iceberg, or SQL Server Columnstore indexes) except as illustrative examples.
> * General database indexing theory not related to differential storage.
> * Hardware-level storage protocols.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Base Store | The primary, highly compressed, and read-optimized persistent storage layer containing the bulk of the dataset. |
| Delta Store | A write-optimized auxiliary storage area that holds changes (deltas) not yet persisted to the Base Store. |
| Compaction | The process of merging records from the Delta Store into the Base Store to optimize read performance and reclaim space. |
| Tombstone | A specialized delta record indicating that a specific entry in the Base Store has been logically deleted. |
| Upsert | A hybrid operation that updates an existing record if it exists in the Base Store or inserts it as a new record if it does not. |
| Merge-on-Read | A strategy where the system combines Base Store data and Delta Store records at query time. |
| Copy-on-Write | A strategy where any change triggers a rewrite of the affected data files in the Base Store, effectively bypassing a long-lived Delta Store. |

## Core Concepts
The fundamental idea behind a Delta Store is the **Differential Storage Principle**. Instead of modifying a large, compressed file to change a single row, the system writes that change to a smaller, more agile "Delta" area.

### The Buffer Analogy
> [!TIP]
> Think of the Base Store as a printed encyclopedia and the Delta Store as a set of sticky notes placed on the pages. When you read the book, you look at the page but check the sticky notes to see if any information has been updated or removed. Eventually, a new edition of the encyclopedia is printed that incorporates all the sticky notes into the main text; this is Compaction.

### Write Path vs. Read Path
*   **Write Path:** Incoming data is appended to the Delta Store. This is typically a low-latency operation because it avoids the overhead of re-compressing or re-sorting the entire dataset.
*   **Read Path:** To provide a consistent view, the system must perform a "union" or "join" between the Base Store and the Delta Store. The system must ensure that if a record exists in both, the version in the Delta Store (the most recent) takes precedence.

## Standard Model
The standard model for Delta Stores follows a cyclical lifecycle:

1.  **Ingestion:** New data arrives and is written to a Write-Ahead Log (WAL) and then into the Delta Store (often in-memory or on high-speed SSDs).
2.  **Querying:** The query engine intercepts requests, scanning the Base Store and applying the modifications found in the Delta Store.
3.  **Threshold Trigger:** Once the Delta Store reaches a specific size, age, or record count, a background process is triggered.
4.  **Compaction/Merge:** The system reads the Base Store and the Delta Store, merges them into a new version of the Base Store, and clears the Delta Store.
5.  **Vacuuming:** Old versions of the Base Store and processed Delta logs are purged to reclaim physical storage.

## Common Patterns

### 1. Log-Structured Merge-Trees (LSM)
A pattern where data is written to a sorted mutable memtable (Delta) and periodically flushed to immutable sorted files (Base). This is the foundation of many NoSQL and modern analytical engines.

### 2. Sidecar Delta Files
In data lake environments, deltas are often stored as small "sidecar" files (e.g., Parquet or Avro) alongside the main data files. Metadata layers track which sidecars belong to which base files.

### 3. Delete Bitmaps
A specific type of Delta Store used primarily for deletions. Instead of storing the full record, the Delta Store maintains a bitset or a list of row IDs that should be ignored during the scan of the Base Store.

## Anti-Patterns
Common mistakes or discouraged practices.

*   **Small File Syndrome:** Allowing the Delta Store to create thousands of tiny files without frequent compaction, which degrades read performance due to excessive I/O metadata overhead.
*   **Infinite Delta Growth:** Failing to schedule compaction, leading to a Delta Store that rivals the Base Store in size, negating the performance benefits of the optimized base format.
*   **Synchronous Merging:** Attempting to merge the Delta into the Base Store as part of the user's write transaction, which introduces significant latency and defeats the purpose of having a Delta Store.

> [!CAUTION]
> Avoid circular dependencies where the Delta Store requires a full scan of the Base Store to validate uniqueness before every write, as this creates a massive performance bottleneck.

## Edge Cases

*   **Schema Evolution:** When the Delta Store contains records with a different schema than the Base Store. The merge process must handle type promotion or null-filling for missing columns.
*   **Late-Arriving Data:** Data that arrives after a compaction cycle has already moved its "logical time" forward. The system must decide whether to create a new delta or trigger a re-compaction of historical segments.
*   **Conflict Resolution:** In multi-writer environments, two different Delta Stores might attempt to update the same record in the Base Store simultaneously. Standard resolution strategies (e.g., "Last Writer Wins" or version vectors) must be applied.

## Related Topics
*   **Columnar Storage:** The primary format used for Base Stores in analytical contexts.
*   **Write-Ahead Logging (WAL):** The mechanism used to ensure durability of the Delta Store before it is persisted.
*   **Data Versioning/Time Travel:** The ability to query the Base Store by ignoring specific Delta Store states.
*   **LSM-Trees:** The data structure most commonly used to implement efficient Delta Stores.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |