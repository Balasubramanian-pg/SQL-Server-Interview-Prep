# 40. Snapshot Isolation Row Versioning

Canonical documentation for [40. Snapshot Isolation Row Versioning](1. Database Architecture Internals/40. Snapshot Isolation Row Versioning.md). This document defines concepts, terminology, and standard usage.

## Purpose
Snapshot Isolation (SI) and Row Versioning exist to provide high levels of concurrency in database systems by decoupling read operations from write operations. In traditional locking models, readers often block writers and writers block readers. Row versioning addresses this by maintaining multiple versions of data, allowing a transaction to see a "snapshot" of the database as it existed at a specific point in time.

The primary goal is to provide transactionally consistent reads without the performance penalties associated with heavy locking, effectively eliminating "dirty reads" and "non-repeatable reads" while significantly reducing contention.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural pattern rather than specific database engine syntax.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Multi-Version Concurrency Control (MVCC) mechanics.
> * The lifecycle of a row version.
> * Transactional consistency boundaries.
> * Conflict detection and resolution logic.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., SQL Server's TempDB usage, PostgreSQL's VACUUM specifics, or Oracle's Undo Tablespace).
> * Physical storage hardware optimization.
> * Distributed consensus protocols (e.g., Paxos/Raft) unless directly related to versioning.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **MVCC** | Multi-Version Concurrency Control; a method used to provide concurrent access to the database by maintaining multiple versions of data objects. |
| **Snapshot** | A logically consistent view of the data as it existed at a specific point in time, usually defined by the start of a transaction or the start of a statement. |
| **Row Version** | A specific iteration of a data record, typically tagged with a timestamp or transaction ID to denote its validity period. |
| **Write Skew** | A phenomenon where two transactions (A and B) read the same data, but modify different sets of data that overlap in a way that violates a business rule that would have been caught if they ran serially. |
| **Version Store** | A logical or physical storage area where older versions of modified rows are kept until they are no longer needed by any active transaction. |
| **Visibility Map** | A mechanism used to determine which version of a row is "visible" to a specific transaction based on its start time. |

## Core Concepts
The fundamental idea behind Snapshot Isolation is that "Readers do not block Writers, and Writers do not block Readers."

### The Snapshot Mechanism
When a transaction begins under Snapshot Isolation, the system records the current state of the database (or a logical equivalent, such as the highest committed Transaction ID). Throughout the life of that transaction, every query performed sees the data exactly as it was at that initial moment. Even if other transactions commit changes to those same rows, the current transaction remains isolated in its temporal "snapshot."

### Row Versioning Lifecycle
1.  **Creation:** When a row is updated, the system does not overwrite the old data. Instead, it creates a new version of the row.
2.  **Identification:** Each version is marked with the ID of the transaction that created it and, eventually, the ID of the transaction that deleted or superseded it.
3.  **Traversal:** When a reader accesses a row, the system traverses the "version chain" to find the most recent version that was committed before the reader's snapshot began.
4.  **Garbage Collection:** Once a version is older than the oldest active transaction snapshot, it is considered "stale" and can be physically removed to reclaim space.

> [!TIP]
> Think of Row Versioning like a version control system (e.g., Git) for every single row in your database. Instead of locking a file so no one else can read it while you edit, you create a new "commit." Others continue to see the previous "commit" until they choose to refresh their view.

## Standard Model
The generally accepted model for Snapshot Isolation Row Versioning follows these operational phases:

1.  **Transaction Initiation:** The system assigns a unique Transaction ID (XID) and captures the "Snapshot Descriptor" (a list of all currently active XIDs).
2.  **Read Operations:**
    *   The system checks the row's metadata.
    *   If the row was committed before the current transaction started, it is read.
    *   If the row was modified by a transaction that was still active when the current transaction started, the system follows the pointer to the previous version in the Version Store.
3.  **Write Operations:**
    *   The transaction creates a new version of the row.
    *   The new version is tagged with the current XID.
    *   The old version is updated with an "expired" tag pointing to the new XID.
4.  **Commit/Conflict Detection:**
    *   The system checks if any other transaction has modified the same row since the current transaction's snapshot was taken (First-Writer-Wins rule).
    *   If a conflict is detected, the current transaction is aborted.
    *   If no conflict exists, the transaction commits, and its changes become visible to snapshots started after this point.

## Common Patterns
*   **Read-Heavy Workloads:** SI is ideal for environments where reporting and analytics occur simultaneously with data entry.
*   **Optimistic Concurrency:** SI is often used to implement optimistic concurrency control, where the system assumes conflicts are rare and only checks for them at commit time.
*   **Temporal Auditing:** Because multiple versions of rows exist, some systems leverage row versioning to provide "As Of" queries, allowing users to query the database state at any arbitrary point in history.

## Anti-Patterns
*   **Long-Running Transactions:** Keeping a transaction open for an extended period prevents the system from cleaning up old versions, leading to "Version Store Bloat" and performance degradation.
*   **Ignoring Write Skew:** Developers often assume Snapshot Isolation is equivalent to Serializability. This is a mistake; SI does not prevent write skew, which can lead to data integrity issues in complex multi-row constraints.
*   **High-Update Frequency on Single Rows:** Rapidly updating the same row creates long version chains, which increases the CPU cost for readers who must traverse these chains to find the correct version.

> [!CAUTION]
> Do not use Snapshot Isolation as a blanket solution for all concurrency needs. If your application requires absolute serial consistency across multiple tables (e.g., complex financial transfers), SI may require additional manual locking or a move to full Serializable isolation.

## Edge Cases
*   **Transaction ID Wraparound:** In systems using finite integers for Transaction IDs, the system must handle the "wraparound" where the ID counter resets to zero, ensuring old versions aren't suddenly perceived as being in the future.
*   **Version Store Overflow:** If the storage area for row versions (e.g., memory or a specific disk segment) fills up, the system may be forced to kill long-running transactions or revert to more restrictive locking.
*   **Ghost Records:** Rows that are deleted are not immediately removed; they are marked as "deleted" versions. If a table has a high volume of deletes, "ghost records" can cause index scans to slow down significantly until garbage collection occurs.

## Related Topics
*   **ACID Properties:** The foundational requirements for reliable transactions.
*   **Isolation Levels:** The hierarchy of transaction isolation (Read Uncommitted, Read Committed, Repeatable Read, Snapshot, Serializable).
*   **Optimistic vs. Pessimistic Concurrency:** The two primary philosophies of managing simultaneous data access.
*   **Garbage Collection / Vacuuming:** The process of reclaiming space from obsolete row versions.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |