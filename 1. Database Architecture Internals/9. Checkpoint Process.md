# 9. Checkpoint Process

Canonical documentation for [9. Checkpoint Process](1. Database Architecture Internals/9. Checkpoint Process.md). This document defines concepts, terminology, and standard usage.

## Purpose
The Checkpoint Process exists to synchronize the volatile state of a system (RAM) with its persistent storage (Disk). Its primary objective is to minimize the time required for system recovery following a failure and to ensure data durability. By establishing a known "good" state on persistent media, the system can safely discard historical transaction logs or redo records that precede the checkpoint, thereby managing storage efficiency and operational stability.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural necessity of state synchronization rather than specific database engine mechanics.

## Scope
This documentation covers the theoretical framework and operational logic governing how systems transition from transient memory states to hardened persistent states.

> [!IMPORTANT]
> **In scope:**
> * Mechanisms for identifying "dirty" data (modified but not persisted).
> * The relationship between Write-Ahead Logging (WAL) and the checkpointing event.
> * Impact on Recovery Time Objective (RTO) and Recovery Point Objective (RPO).
> * Coordination between memory buffers and storage I/O.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., specific PostgreSQL, SQL Server, or Oracle internal flags).
> * Hardware-level caching (e.g., NVMe controller caches) unless managed by the software process.
> * Application-level "save points" that do not involve system-level persistence.

## Definitions
| Term | Definition |
|------|------------|
| Dirty Page | A block of data in volatile memory that has been modified but not yet written to persistent storage. |
| Flush | The operation of forcibly writing data from a memory buffer to a physical storage device. |
| Hard Checkpoint | A process that ensures all modified data is written to disk and the log is fully synchronized before the process completes. |
| Fuzzy Checkpoint | A non-blocking process where the system records a starting point and gradually flushes pages without halting active transactions. |
| Log Sequence Number (LSN) | A unique identifier used to track the order of operations in a transaction log, essential for determining the checkpoint boundary. |
| Quiesce | The act of pausing or slowing down new operations to achieve a consistent state for checkpointing. |

## Core Concepts
The Checkpoint Process is the bridge between the speed of volatile memory and the reliability of persistent storage. 

Systems typically use a **Write-Ahead Log (WAL)** to record changes immediately. However, replaying a log from the beginning of time during a recovery is inefficient. The checkpoint acts as a "bookmark" in the log.

> [!TIP]
> Think of a checkpoint like an auto-save feature in a video game. While the game tracks every movement you make (the log), the auto-save (the checkpoint) consolidates your progress into a single file. If the power goes out, you only have to "replay" the few minutes of gameplay that occurred after the last auto-save, rather than restarting the entire game.

### The Durability Trade-off
Frequent checkpoints reduce recovery time (RTO) because there is less log data to replay. However, frequent checkpoints increase I/O overhead, potentially degrading system performance during normal operation. Balancing this frequency is a core requirement of system tuning.

## Standard Model
The standard model for a checkpoint process follows a specific lifecycle:

1.  **Triggering:** The process is initiated by a timer, a log volume threshold, or a manual command.
2.  **Identification:** The system identifies all "dirty" pages currently residing in the buffer pool.
3.  **Persistence (The Flush):** The system issues I/O requests to write these pages to persistent storage.
4.  **Metadata Update:** Once the flush is confirmed by the storage layer, the system updates a "Checkpoint Record" or "Control File" with the latest LSN.
5.  **Log Truncation:** Any log entries older than the checkpoint are marked as eligible for deletion or reuse, as they are no longer needed for crash recovery.

## Common Patterns
*   **Time-Based Checkpointing:** Occurs at fixed intervals (e.g., every 5 minutes). This provides a predictable RTO.
*   **Volume-Based Checkpointing:** Occurs after a certain amount of data has been written to the log (e.g., every 1GB of logs). This prevents log files from consuming all available disk space.
*   **Indirect Checkpointing:** A modern approach where the system continuously flushes dirty pages in the background to maintain a target "recovery time" rather than performing a massive burst of I/O.
*   **Shutdown Checkpoint:** A mandatory hard checkpoint performed when a system is closed gracefully to ensure no log replay is needed upon the next start.

## Anti-Patterns
*   **Synchronous Blocking:** Halting all incoming transactions while a checkpoint is in progress. This leads to "latency spikes" and poor user experience.
*   **Checkpoint Surges:** Allowing too many dirty pages to accumulate, causing a massive I/O bottleneck when the checkpoint finally triggers.
*   **Ignoring I/O Priority:** Running checkpoint flushes at the same priority as user queries, which can starve the system of resources.

> [!CAUTION]
> Avoid configuring checkpoints solely based on time without considering log volume. In high-velocity environments, this can lead to disk exhaustion before the next scheduled checkpoint occurs.

## Edge Cases
*   **Storage Full during Flush:** If the persistent storage runs out of space during a checkpoint, the system must remain in a "partially dirty" state. The checkpoint is considered failed, and the log cannot be truncated.
*   **Crash during Checkpoint:** If the system fails while writing the checkpoint record, the recovery process must revert to the *previous* successful checkpoint and replay the log from that point.
*   **Long-Running Transactions:** A transaction that started before the checkpoint and hasn't finished cannot have its log entries removed, even if they are older than the checkpoint. This can prevent log truncation and lead to "log pinning."

## Related Topics
*   **Write-Ahead Logging (WAL):** The primary mechanism that allows checkpoints to exist by decoupling change recording from data persistence.
*   **Crash Recovery:** The process that utilizes checkpoint records to restore system state.
*   **Buffer Management:** The subsystem responsible for tracking dirty pages and managing memory pressure.
*   **ACID Properties:** Specifically "Durability," which the checkpoint process helps guarantee.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |