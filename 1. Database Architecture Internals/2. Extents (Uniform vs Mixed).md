# 2. Extents (Uniform vs Mixed)

Canonical documentation for [2. Extents (Uniform vs Mixed)](1. Database Architecture Internals/2. Extents (Uniform vs Mixed).md). This document defines concepts, terminology, and standard usage.

## Purpose
The concept of extents exists to bridge the gap between individual data blocks (pages) and entire data files. Extents address the overhead associated with space management by grouping blocks into manageable units. The distinction between Uniform and Mixed extents specifically addresses the "Small Object Problem"—the inefficiency of allocating large, contiguous chunks of storage to objects that may only contain a few rows of data.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural logic of storage allocation rather than specific software syntax.

## Scope
This documentation covers the logical grouping of storage blocks and the strategies used to allocate them to database objects or files.

> [!IMPORTANT]
> **In scope:**
> * Logical storage hierarchies (Pages -> Extents -> Segments/Files)
> * Allocation efficiency and performance trade-offs
> * Transition logic between shared and dedicated storage units

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific commands (e.g., T-SQL or Oracle-specific parameters)
> * Physical disk sector geometry or hardware-level controller logic

## Definitions
| Term | Definition |
|------|------------|
| Block (Page) | The smallest unit of I/O in a storage system. |
| Extent | A physical grouping of a fixed number of contiguous blocks. |
| Uniform Extent | An extent where all blocks are owned by and reserved for a single object. |
| Mixed Extent | An extent where individual blocks can be owned by different objects. |
| Allocation Map | A metadata structure used to track the status (free/used) of extents. |
| Object | A logical entity requiring storage, such as a table, index, or metadata stream. |

## Core Concepts
The fundamental idea behind extents is the balance between **granularity** and **performance**. 

If a system allocated space one block at a time, the metadata required to track those blocks would become massive, and data would become highly fragmented. If a system allocated space only in large chunks, small tables would waste significant amounts of storage.

### The Hierarchy of Allocation
1. **Block/Page:** The atomic unit of data.
2. **Extent:** The unit of allocation. Systems typically do not grow by one block; they grow by one extent.
3. **Object/Segment:** The logical collection of extents representing a table or index.

> [!TIP]
> Think of an extent as a "floor" in a building. A **Uniform Extent** is like a corporate office floor where one company owns every room. A **Mixed Extent** is like a co-working space where different startups rent individual desks on the same floor.

## Standard Model
In a standard storage model, the system manages the lifecycle of an object's growth through a transition from Mixed to Uniform extents.

1. **Initialization:** When a new object is created, the system allocates a block within a **Mixed Extent**. This prevents the system from wasting a full extent (e.g., 64KB or 1MB) on a table that might only ever hold 2KB of data.
2. **Growth:** As the object grows and fills its initial blocks, it continues to occupy blocks in Mixed Extents.
3. **Threshold Reached:** Once the object reaches a predefined size (typically 8 blocks), the system stops using Mixed Extents for that object.
4. **Uniform Allocation:** All subsequent growth for that object is handled via **Uniform Extents**. The object now owns every block in any new extent allocated to it, ensuring contiguity and better I/O performance for scans.

## Common Patterns
### Small Table Optimization
Systems with thousands of small lookup tables rely heavily on Mixed Extents to keep the total database footprint small. Without Mixed Extents, a database with 5,000 empty tables would still consume significant gigabytes of "reserved" but empty space.

### Bulk Load Performance
When performing bulk data ingestion, systems often bypass Mixed Extents entirely. Since the system knows the object will grow rapidly, it allocates Uniform Extents immediately to minimize the overhead of searching for free blocks in shared extents.

## Anti-Patterns
### Excessive Mixed Extent Fragmentation
Relying on Mixed Extents for large objects is an anti-pattern. Because blocks in a Mixed Extent can belong to different objects, a large table spread across many Mixed Extents will suffer from "interleaved" fragmentation, forcing storage headers to perform more seeks during sequential scans.

> [!CAUTION]
> Avoid configurations that force all allocations to be Uniform in environments with high numbers of small, transient objects, as this leads to "Internal Fragmentation" (allocated but unused space).

## Edge Cases
### High-Concurrency Allocation Contention
In systems with extremely high insert rates across many small tables, the metadata structures tracking Mixed Extents (often called Shared Global Allocation Maps) can become a bottleneck. In these specific scenarios, forcing Uniform Extents—even for small tables—can improve performance by reducing contention on the allocation metadata.

### Read-Only Media
On read-only or write-once media, the distinction between Uniform and Mixed extents is often collapsed during the final "packing" phase to maximize density, as the performance benefits of future contiguous growth are no longer relevant.

## Related Topics
* **Page Fragmentation:** The internal or external scattering of data.
* **IAM (Index Allocation Map):** The mechanism used to track which extents belong to which object.
* **Fill Factor:** How much space is left empty within blocks for future growth.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |