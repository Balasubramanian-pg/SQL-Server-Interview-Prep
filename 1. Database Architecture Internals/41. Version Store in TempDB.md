# 41. Version Store in TempDB

Canonical documentation for [41. Version Store in TempDB](1. Database Architecture Internals/41. Version Store in TempDB.md). This document defines concepts, terminology, and standard usage.

## Purpose
The Version Store in TempDB is a specialized storage mechanism designed to support Multi-Version Concurrency Control (MVCC). Its primary purpose is to facilitate non-blocking read operations by maintaining historical versions of data rows that are currently being modified by active transactions. 

By offloading these historical versions to a global temporary workspace (TempDB), the system ensures that "readers do not block writers and writers do not block readers." This addresses the fundamental problem of data contention in high-concurrency environments, allowing for consistent data snapshots without the overhead of traditional shared locks.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural role of versioning within a centralized temporary storage system.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The lifecycle of row versions within a temporary storage environment.
> * The mechanism of row-version linking and retrieval.
> * The impact of isolation levels on version store utilization.
> * Garbage collection and maintenance of the versioning space.

> [!WARNING]
> **Out of scope:**
> * Specific hardware configuration for disk I/O optimization.
> * Proprietary syntax for enabling specific isolation levels in individual SQL dialects.
> * In-memory optimized table versioning (which typically bypasses physical temporary storage).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **MVCC** | Multi-Version Concurrency Control; a method used to provide concurrent access to data by maintaining multiple versions of the same data object. |
| **Row Versioning** | The process of appending a pointer to a data row that links to its previous state stored in the version store. |
| **Snapshot Isolation** | An isolation level where a transaction sees a consistent snapshot of the database as it existed at the start of the transaction. |
| **Garbage Collection** | The background process responsible for removing row versions that are no longer needed by any active transaction. |
| **Version Chain** | A linked list of row versions, starting from the current data page and pointing back through successive historical states in the version store. |

## Core Concepts
The Version Store operates on the principle of "Copy-on-Write." When a record is modified, the system does not simply overwrite the existing data. Instead, it copies the pre-modification state of the row to the Version Store in TempDB.

### The Version Pointer
Every data row in the primary storage includes a hidden 14-byte pointer (in standard implementations) when versioning is enabled. This pointer contains the location of the previous version in TempDB. If that version was also a modification, it contains a pointer to the version before it, creating a "Version Chain."

### Transaction Consistency
When a reader requests data under a versioning-based isolation level, the engine checks the transaction's timestamp against the timestamp of the current row. If the row is "too new" (modified after the reader's transaction began), the engine follows the pointer to TempDB to find the version that matches the reader's point-in-time snapshot.

> [!TIP]
> Think of the Version Store as a "Time Machine" for data. The main database always shows the "Present," while TempDB stores the "Past" for anyone who isn't ready to move to the present yet.

## Standard Model
The standard model for Version Store management follows a four-stage lifecycle:

1.  **Initialization:** The database engine flags a row for versioning upon the first DML (Data Manipulation Language) operation after versioning is enabled.
2.  **Version Generation:** As updates or deletes occur, the "before image" of the row is pushed to the Version Store.
3.  **Version Access:** Concurrent read transactions traverse the version chain in TempDB to reconstruct the data as it appeared at their specific transaction start time.
4.  **Cleanup:** A background thread periodically scans the Version Store. It identifies versions that are older than the oldest active transaction and marks that space for deallocation.

## Common Patterns
*   **Read Committed Snapshot Isolation (RCSI):** A statement-level consistency model where each query sees a snapshot of the data as it existed at the start of the statement. This significantly reduces locking contention.
*   **Snapshot Isolation (SI):** A transaction-level consistency model where all statements within a transaction see the data as it existed at the start of the transaction.
*   **Online Index Operations:** Using the version store to maintain data availability while an index is being rebuilt or altered.

## Anti-Patterns
*   **Long-Running Transactions:** Keeping a transaction open for hours (e.g., waiting for user input) prevents the garbage collector from cleaning up the Version Store. This leads to "Version Store Bloat."
*   **Massive Singleton Updates:** Updating millions of rows in a single transaction can overwhelm the Version Store's capacity and cause TempDB to run out of space.
*   **Unnecessary Versioning:** Enabling versioning on databases with exclusively single-user access or purely read-only workloads adds unnecessary overhead to TempDB.

> [!CAUTION]
> Avoid "Ghost Transactions"â€”sessions that are left open and forgotten. A single uncommitted transaction can prevent the cleanup of millions of versions, eventually causing a system-wide failure when TempDB reaches maximum capacity.

## Edge Cases
*   **Version Store Overlap:** If TempDB runs out of space, the system may be unable to generate new versions. In some implementations, this forces readers to fail or revert to blocking behavior.
*   **Deep Version Chains:** If a single row is updated thousands of times while a long-running transaction is active, the "chain" becomes very long. A reader needing the oldest version must traverse the entire chain, leading to significant CPU and I/O overhead.
*   **DDL Operations:** Most versioning systems handle DML (updates/deletes), but structural changes (DDL) to a table can sometimes invalidate the version chain or require complex mapping to maintain consistency.

## Related Topics
*   **TempDB Management:** The broader administration of the temporary workspace.
*   **Transaction Isolation Levels:** The logical rules that dictate how the Version Store is utilized.
*   **Concurrency Control:** The theoretical framework (Pessimistic vs. Optimistic) that necessitates a Version Store.
*   **Write-Ahead Logging (WAL):** How versioning interacts with the transaction log to ensure durability.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |