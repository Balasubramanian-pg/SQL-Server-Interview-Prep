# 23. Ghost Records and Cleanup

Canonical documentation for [23. Ghost Records and Cleanup](1. Database Architecture Internals/23. Ghost Records and Cleanup.md). This document defines concepts, terminology, and standard usage.

## Purpose
The concept of Ghost Records and Cleanup addresses the inherent performance and concurrency challenges associated with physical data removal in high-throughput storage engines. In many database systems, performing a physical deletion of a record during a transaction is computationally expensive and can lead to significant locking contention.

Ghosting allows a system to perform a "logical delete" by marking a record as deleted without immediately removing it from the physical storage medium. This ensures that the `DELETE` operation completes rapidly, while the actual reclamation of space and reorganization of data structures are deferred to an asynchronous background process.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural necessity of deferred deletion in B-tree and similar storage structures.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The lifecycle of a record from logical deletion to physical removal.
> * The role of background cleanup processes in maintaining storage health.
> * Impact on concurrency, indexing, and storage efficiency.
> * Interaction between ghost records and transaction isolation levels.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific command syntax (e.g., T-SQL or PL/SQL commands).
> * Hardware-level garbage collection (e.g., SSD TRIM operations).
> * Application-level "soft deletes" (e.g., `is_deleted` columns managed by application logic).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Ghost Record | A record that has been logically deleted but still physically occupies space on a data page. |
| Ghost Cleanup | An asynchronous background process responsible for physically removing ghost records and reclaiming space. |
| Logical Delete | The process of toggling a metadata bit to indicate a record is no longer valid, without moving data. |
| Physical Delete | The actual removal of data from the storage medium and the subsequent compaction of the data page. |
| Page | The fundamental unit of storage in a database, containing multiple records and metadata. |
| Bitmask/Flag | A specific metadata field within a record header used to identify its status (e.g., "Ghost Bit"). |

## Core Concepts
The fundamental idea behind ghost records is the decoupling of the **intent to delete** from the **physical reorganization** of data.

When a delete operation occurs, the system modifies the record's header to set a "ghost bit." From the perspective of any new transaction, this record no longer exists. However, the record remains in the B-tree leaf level to maintain the structural integrity of the index until the transaction that performed the delete is committed and no other active transactions require visibility of that record.

> [!TIP]
> Think of a ghost record like a "Strikethrough" in a physical ledger. You can see the line through the entry, so you know to ignore it, but the ink is still on the paper. The "Cleanup" is the equivalent of an editor eventually rewriting the page to remove the struck-through lines and close the gaps.

## Standard Model
The standard model for Ghost Records and Cleanup follows a specific lifecycle:

1.  **Deletion Request:** A transaction issues a delete command.
2.  **Ghost Marking:** The storage engine locates the record and flips the ghost bit in the record header. This is a minimal-log operation compared to a physical move.
3.  **Transaction Commit:** The transaction completes. The record is now officially a "ghost."
4.  **Cleanup Trigger:** The background cleanup task is notified (or polls) that a page contains ghost records.
5.  **Verification:** The cleanup task verifies that no active transactions still require the ghost record for versioning or consistency (e.g., under Snapshot Isolation).
6.  **Physical Removal:** The cleanup task removes the record, updates the page offsets, and reclaims the space for future inserts.

## Common Patterns
*   **Background Threading:** Most modern systems use a dedicated low-priority background thread to scan for and purge ghost records to minimize impact on user workloads.
*   **On-Demand Cleanup:** Some systems trigger a cleanup of a specific page when a new insert operation requires space on that page and finds it occupied by ghosts.
*   **Log-Based Cleanup:** The cleanup task often uses the transaction log to identify which pages have had deletions, rather than scanning the entire database.

## Anti-Patterns
*   **Disabling Cleanup Tasks:** In some environments, administrators might disable background tasks to save CPU. This leads to "database bloat," where the physical file size grows indefinitely despite many records being deleted.
*   **Massive Batch Deletes without Pauses:** Performing millions of deletes in a single transaction can overwhelm the ghost cleanup task, leading to long-running cleanup cycles and potential log growth issues.
*   **Ignoring Long-Running Transactions:** A single uncommitted transaction can prevent the cleanup of all ghost records generated after it started, leading to massive storage overhead.

> [!CAUTION]
> Avoid circular dependencies where the cleanup task itself generates enough log activity to prevent the log from being truncated, potentially leading to a "disk full" state.

## Edge Cases
*   **Rollbacks:** If a transaction that created a ghost record is rolled back, the ghost bit must be flipped back. The cleanup task must be aware of transaction states to avoid deleting records that are being "un-deleted."
*   **Primary Key Reuse:** If a record is ghosted and a new record with the same primary key is inserted before cleanup, the system must either "revive" the ghost or force an immediate physical cleanup to avoid key violations.
*   **Full Pages:** If a page is 100% full of ghost records, the cleanup task may deallocate the entire page from the B-tree structure, which involves updating pointers in parent nodes.
*   **Read-Only Databases:** In a database transitioned to a read-only state, ghost cleanup cannot occur. Any ghosts present at the time of the transition will remain indefinitely.

## Related Topics
*   **B-Tree Indexing:** The primary data structure where ghost records are managed.
*   **Transaction Isolation Levels:** Specifically Snapshot Isolation and MVCC (Multi-Version Concurrency Control), which dictate how long a ghost must persist.
*   **Write-Ahead Logging (WAL):** The mechanism used to track both the ghosting and the subsequent cleanup for recovery purposes.
*   **Fragmentation:** The result of inefficient or delayed ghost cleanup.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |