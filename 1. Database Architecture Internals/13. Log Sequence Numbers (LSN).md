# 13. Log Sequence Numbers (LSN)

Canonical documentation for [13. Log Sequence Numbers (LSN)](1. Database Architecture Internals/13. Log Sequence Numbers (LSN).md). This document defines concepts, terminology, and standard usage.

## Purpose
The Log Sequence Number (LSN) serves as a unique, monotonically increasing identifier for every record within a transaction log or Write-Ahead Log (WAL). Its primary purpose is to provide a definitive ordering of operations in a persistent data store, ensuring that the system can maintain atomicity, consistency, isolation, and durability (ACID properties).

LSNs address the problem of state synchronization and recovery. In the event of a system failure, the LSN allows the recovery process to determine which operations were successfully committed to disk and which must be replayed (Redo) or reversed (Undo) to restore the system to a consistent state.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
This document covers the theoretical framework and functional requirements of LSNs within transactional systems.

> [!IMPORTANT]
> **In scope:**
> * Core functionality of LSN generation and tracking.
> * Theoretical boundaries of monotonicity and uniqueness.
> * The role of LSNs in recovery protocols (e.g., ARIES).
> * LSN-based synchronization in distributed systems.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., PostgreSQL's `pg_lsn`, SQL Server's 10-byte LSN, or Oracle's SCN).
> * Physical storage formats or byte-level encoding specifics.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Log Sequence Number (LSN) | A unique scalar value representing a specific entry in a sequential transaction log. |
| Write-Ahead Log (WAL) | A family of techniques for providing atomicity and durability by recording changes in a log before applying them to the main data store. |
| Monotonicity | The property of a sequence where each subsequent value is strictly greater than the previous value. |
| Page LSN | A metadata field stored within a data page/block indicating the LSN of the last update applied to that page. |
| Flushed LSN | The highest LSN that has been successfully persisted to non-volatile storage. |
| Checkpoint | A known point in the log where the data files are guaranteed to be synchronized with the log. |

## Core Concepts
The fundamental idea behind an LSN is the creation of a "logical timeline" for data mutations. Because physical time is difficult to synchronize across distributed components, the LSN acts as a logical clock.

### The Ledger Analogy
> [!TIP]
> Think of an LSN as a page and line number in a financial ledger. Even if the ledger is dropped and the pages are scattered, the numbers allow you to reassemble the history of transactions in the exact order they occurred.

### Monotonicity and Ordering
An LSN must be monotonically increasing. This ensures that if $LSN_A < LSN_B$, then the operation associated with $LSN_A$ occurred before the operation associated with $LSN_B$. This ordering is critical for resolving conflicts and ensuring that "Redo" operations are idempotent.

### The Page-LSN Relationship
In most transactional systems, every data page in memory or on disk contains the LSN of the last log record that modified it. This allows the system to compare the Page LSN with the Log LSN during recovery. If the Log LSN is greater than the Page LSN, the system knows the change has not yet been applied to that page.

## Standard Model
The standard model for LSN usage follows the Write-Ahead Logging (WAL) protocol:

1.  **Generation:** When a transaction modifies data, a log record is generated and assigned a new LSN.
2.  **Persistence:** The log record is written to stable storage. The system must ensure the log is flushed up to the transaction's LSN before the transaction is considered "Committed."
3.  **Buffer Management:** A data page cannot be flushed to disk if its Page LSN is greater than the current Flushed LSN. This prevents "unlogged" changes from reaching the persistent data store.
4.  **Recovery:** Upon restart after a crash, the system scans the log. It uses LSNs to determine the starting point for the Redo phase (usually the last Checkpoint LSN) and ensures that no operation is applied twice by checking the Page LSN.

## Common Patterns
*   **Log Shipping:** Using LSNs to synchronize a primary database with a secondary replica. The replica requests all log records starting from its last received LSN.
*   **Point-in-Time Recovery (PITR):** Restoring a database to a specific state by replaying the log and stopping exactly at a target LSN.
*   **Idempotency Keys:** In distributed messaging, LSNs are used to detect and discard duplicate messages that may have been retried during network partitions.

## Anti-Patterns
*   **Non-Sequential LSNs:** Implementing LSNs that do not strictly increase, which breaks the ability to determine the order of operations.
*   **LSN Reuse:** Reusing LSNs after a log truncation or wrap-around without a mechanism to distinguish between "epochs," leading to data corruption.
*   **Business Logic Coupling:** Using LSNs as primary keys for business entities. LSNs are an infrastructure concern and should remain decoupled from the application domain.

> [!CAUTION]
> Avoid circular dependencies where the generation of an LSN depends on a data state that itself requires an LSN to be validated.

## Edge Cases
*   **LSN Wraparound:** In systems with finite LSN bit-widths (e.g., 32-bit or 64-bit), the LSN may eventually reach its maximum value. Systems must implement "epoch" counters or "vacuuming" to handle the reset of the sequence.
*   **Log Truncation:** When old log records are deleted to save space, the system must ensure that no LSNs required for active transactions or pending replicas are removed.
*   **Partial Writes:** If a system crashes while writing a log record, the LSN may be partially written. Recovery logic must be able to detect and discard malformed LSN entries at the end of the log.
*   **Branching Timelines:** In some distributed systems, a "split-brain" scenario may result in two different sets of operations sharing the same LSN range. This requires a "Term" or "Epoch" identifier to be prepended to the LSN.

## Related Topics
*   **Write-Ahead Logging (WAL):** The primary mechanism that utilizes LSNs.
*   **ARIES (Algorithm for Recovery and Isolation Exploiting Semantics):** The industry-standard recovery algorithm based on LSNs.
*   **Vector Clocks:** A related concept for ordering events in distributed systems without a central authority.
*   **Idempotency:** The property where an operation can be applied multiple times without changing the result beyond the initial application.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |