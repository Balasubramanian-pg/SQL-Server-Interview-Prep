# 33. Tuple Mover Process

Canonical documentation for [33. Tuple Mover Process](1. Database Architecture Internals/33. Tuple Mover Process.md). This document defines concepts, terminology, and standard usage.

## Purpose
The Tuple Mover Process exists to resolve the inherent conflict between high-speed data ingestion and high-performance analytical querying. In columnar and hybrid storage architectures, data is often initially received in a format optimized for write throughput (frequently in-memory or row-oriented). However, for long-term storage and complex analytical queries, data must be reorganized into a compressed, sorted, and column-oriented format.

The Tuple Mover acts as an autonomous background agent that manages the lifecycle of data segments, transitioning them from transient, write-optimized states to permanent, read-optimized states without interrupting active database operations.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural pattern rather than specific software versions.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The transition mechanics between Write-Optimized Storage (WOS) and Read-Optimized Storage (ROS).
> * Data compaction and merge-out logic.
> * The reclamation of storage space through the purging of deleted records.
> * Resource arbitration for background maintenance tasks.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific command-line syntax or configuration parameters.
> * Hardware-level disk I/O scheduling.
> * Front-end query execution engines, except where they interact with storage containers.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Write-Optimized Store (WOS) | A memory-resident or uncompressed storage area designed to accept high-frequency inserts with minimal latency. |
| Read-Optimized Store (ROS) | A disk-resident, highly compressed, and sorted storage format optimized for high-speed analytical aggregation. |
| Move Operation | The process of migrating data from the WOS to the ROS, typically involving sorting and encoding. |
| Merge Operation | The consolidation of multiple small ROS containers into fewer, larger containers to reduce fragmentation. |
| Purge Operation | The physical removal of data records that have been logically marked for deletion. |
| Epoch | A logical timestamp used to track data visibility and determine when data is eligible for purging. |

## Core Concepts
The Tuple Mover operates on the principle of **deferred maintenance**. Instead of forcing the database to perform expensive sorting and compression during every `INSERT` or `UPDATE` statement, these tasks are offloaded to the Tuple Mover.

### The Storage Hierarchy
Data typically flows through three stages:
1.  **Ingestion:** Data enters the WOS. It is often unsorted or minimally indexed to ensure the ingestion pipeline is not bottlenecked.
2.  **Migration (Move):** When the WOS reaches a capacity threshold or a time limit, the Tuple Mover "moves" the data to the ROS. During this move, the data is sorted according to the table's projection or index definition and compressed.
3.  **Consolidation (Merge):** Over time, many small ROS files (containers) are created. The Tuple Mover performs a "Merge-Out" to combine these into larger, more efficient structures, maintaining the sort order across the new, larger segment.

> [!TIP]
> Think of the Tuple Mover as a librarian. Ingestion is like a book drop-box where books are piled haphazardly for speed. The Tuple Mover is the librarian who periodically takes the pile, sorts the books by category, and places them neatly on the shelves for readers to find quickly.

## Standard Model
The standard model for a Tuple Mover involves two primary sub-processes:

1.  **The Mover (WOS to ROS):**
    *   Monitors the memory usage of the WOS.
    *   Triggers when a "High Water Mark" is reached.
    *   Writes data to disk in a format that matches the physical schema.

2.  **The Merger (ROS to ROS):**
    *   Monitors the number of storage containers per object.
    *   Prevents "container explosion," which degrades query performance (as the engine must open and seek through too many files).
    *   Enforces the "Ancient History Mark" (AHM) to determine which deleted rows can be safely discarded during the merge.

## Common Patterns
*   **Threshold-Based Execution:** The process triggers automatically when WOS memory exceeds a defined percentage (e.g., 85%) or when the number of ROS containers exceeds a specific count.
*   **Time-Based Execution:** The process triggers at set intervals to ensure that even low-volume tables are eventually moved to optimized storage.
*   **Manual Intervention:** Administrators may trigger a "Manual Merge" or "Manual Purge" during maintenance windows to prepare the system for heavy reporting periods.

## Anti-Patterns
*   **Trickle Loading to ROS:** Bypassing the WOS and writing directly to ROS in very small increments. This creates massive fragmentation and overwhelms the Tuple Mover's ability to merge files.
*   **Disabling the Mover:** Turning off background move/merge processes to save CPU. This leads to eventual system exhaustion (WOS overflow) or catastrophic query performance degradation.
*   **Excessive Deletions:** Performing frequent, small-batch deletes without allowing the Tuple Mover sufficient time or resources to purge the data, leading to "ghost" data occupying space.

> [!CAUTION]
> Avoid configurations where the Tuple Mover is starved of CPU or I/O resources. If the rate of data ingestion consistently exceeds the Tuple Mover's ability to merge and purge, the system will eventually reach a "Write Stall" state.

## Edge Cases
*   **Schema Evolution:** If a table schema changes while the Tuple Mover is processing a segment, the mover must either abort the current operation or apply the transformation to the data being moved.
*   **Node Failure:** In distributed systems, if a node fails during a move operation, the system must ensure atomicityâ€”either the move completes on a surrogate node or the partial ROS files are cleaned up upon recovery.
*   **Long-Running Queries:** The Tuple Mover cannot purge deleted data that is still "visible" to a query that started before the deletion. This can cause storage usage to remain high until the oldest query completes.

## Related Topics
*   **Columnar Storage:** The underlying format that the Tuple Mover optimizes for.
*   **Log-Structured Merge-Trees (LSM):** A similar architectural pattern used in many NoSQL databases for managing write-ahead logs and sorted tables.
*   **Data Compression and Encoding:** The specific techniques applied by the Tuple Mover during the transition to ROS.
*   **Concurrency Control (MVCC):** The mechanism that dictates when data is "safe" to be purged by the Tuple Mover.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |