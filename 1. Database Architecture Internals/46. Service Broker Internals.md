# 46. Service Broker Internals

Canonical documentation for [46. Service Broker Internals](1. Database Architecture Internals/46. Service Broker Internals.md). This document defines concepts, terminology, and standard usage.

## Purpose
The Service Broker pattern exists to decouple the consumption of services from their underlying infrastructure and lifecycle management. In modern distributed systems, applications often require external resources—such as databases, message queues, or specialized APIs—without needing to understand the complexities of how those resources are provisioned, scaled, or secured.

The Service Broker acts as an intermediary layer that translates high-level requests from a platform (the "Consumer") into specific actions performed on a service provider (the "Resource"). By standardizing the interface for these interactions, organizations can achieve consistent service delivery across heterogeneous environments.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural mechanics rather than specific software versions.

## Scope
This documentation covers the internal logic, state management, and communication protocols inherent to service brokerage.

> [!IMPORTANT]
> **In scope:**
> * The lifecycle of service instances and bindings.
> * The structure and role of the Service Catalog.
> * Asynchronous vs. synchronous operation patterns.
> * State reconciliation and consistency models.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., AWS Service Broker, Azure Service Broker).
> * Specific API specifications (e.g., OSBAPI) except where used to illustrate universal concepts.
> * Network-level configuration (DNS, Firewalls) unless directly related to the broker's internal logic.

## Definitions
| Term | Definition |
|------|------------|
| Service Broker | A component that manages the lifecycle of services via a standardized API. |
| Catalog | A manifest provided by the broker describing the services and plans available for consumption. |
| Service Instance | A specific instantiation of a service defined in the catalog. |
| Service Binding | A set of credentials and connection details that allow an application to access a Service Instance. |
| Plan | A specific tier or configuration of a service (e.g., "small," "high-availability," "premium"). |
| Provisioning | The process of creating and configuring a new Service Instance. |
| Deprovisioning | The process of deleting a Service Instance and reclaiming its resources. |
| Last Operation | A mechanism for tracking the progress of long-running asynchronous tasks. |

## Core Concepts

### The Broker API Contract
The Service Broker operates on a contract-first basis. It must expose a set of endpoints that allow a platform to query capabilities and request lifecycle changes. This contract ensures that the platform does not need to know the internal implementation details of the service it is requesting.

### The Catalog
The Catalog is the "source of truth" for what a broker can provide. It is a static or dynamic metadata document that lists services, their unique identifiers, and the various plans available. 

> [!TIP]
> Think of the Catalog as a menu in a restaurant. The customer (Platform) sees the options and prices (Plans), but the kitchen (Service Broker) handles the complexity of preparing the meal (Provisioning).

### Statefulness and Persistence
While a broker may appear as a stateless proxy, it must maintain internal state or rely on the underlying resource's state to ensure consistency. It must track which instances exist, which bindings are active, and the status of ongoing operations to prevent resource leakage or orphaned services.

## Standard Model

The standard model for Service Broker internals follows a request-response cycle, often augmented by a polling mechanism for asynchronous tasks.

1.  **Catalog Fetch:** The platform requests the catalog to understand available services.
2.  **Provisioning:** The platform requests a new instance. The broker validates the request, generates a unique ID, and initiates the resource creation.
3.  **Binding:** Once an instance is ready, the platform requests a binding. The broker generates credentials (e.g., usernames, passwords, certificates) and returns them to the platform.
4.  **Consumption:** The application uses the provided credentials to access the service directly. The broker is typically *not* in the data path.
5.  **Unbinding/Deprovisioning:** The platform requests the removal of credentials and the eventual destruction of the resource.

### Asynchronicity
Because provisioning complex resources (like a multi-node database cluster) can take minutes, the standard model utilizes an "Accepted" status. The broker returns a 202 Accepted response, and the platform polls a "Last Operation" endpoint until the process is complete.

> [!IMPORTANT]
> The broker must ensure idempotency. If a provision request is received twice with the same ID, the broker should return the current state of that instance rather than attempting to create a second one.

## Common Patterns

### The Proxy Pattern
The broker acts as a thin wrapper around an existing API (e.g., a cloud provider's RDS API). It translates generic "Provision" calls into provider-specific API calls.

### The Sidecar/Operator Pattern
In containerized environments, the broker may trigger the deployment of specific controllers or operators that manage the resource lifecycle natively within the cluster orchestration layer.

### Shared vs. Dedicated Instances
*   **Dedicated:** Each provision request results in a new, isolated resource (e.g., a new VM).
*   **Shared:** Multiple provision requests result in logical isolation within a single large resource (e.g., new schemas within a single shared database server).

## Anti-Patterns

### Data Path Interception
The Service Broker should never sit in the middle of the application's data traffic. Its role is strictly control-plane management.

> [!CAUTION]
> Routing application data through a broker introduces a single point of failure and significant latency bottlenecks.

### Synchronous Blocking on Long Tasks
Attempting to hold an HTTP connection open while a 10-minute database provisioning occurs leads to timeouts and platform instability.

### Hardcoded Credentials
Brokers should generate unique credentials per binding rather than sharing a single administrative account across all consumers.

## Edge Cases

### Orphaned Resources
If a platform loses track of a request (e.g., due to a crash) after the broker has started provisioning, the resource becomes "orphaned." Internal broker logic should include reconciliation loops or cleanup tasks to identify and reap resources that have no corresponding platform record.

### Catalog Updates
When a service plan is removed from the catalog, existing instances must be handled gracefully. The broker must decide whether to allow deprovisioning of "invisible" plans or to force a migration to a newer plan.

### Partial Failures during Binding
If a binding requires multiple steps (e.g., creating a user AND setting permissions), and the second step fails, the broker must roll back the first step to ensure no "hanging" credentials exist.

## Related Topics
*   **Service Discovery:** How applications find the service once bound.
*   **Identity and Access Management (IAM):** The underlying security models used during binding.
*   **Infrastructure as Code (IaC):** The tools often used by brokers to execute provisioning.
*   **Control Plane vs. Data Plane:** The architectural distinction between management and usage.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |