# 27. Fixed vs Variable Length Data Storage

Canonical documentation for [27. Fixed vs Variable Length Data Storage](1. Database Architecture Internals/27. Fixed vs Variable Length Data Storage.md). This document defines concepts, terminology, and standard usage.

## Purpose
The purpose of data storage length strategies is to manage the trade-off between computational efficiency and storage density. In any data persistence or transmission system, the architecture must decide whether to allocate a constant amount of space for every record (Fixed) or to allocate only the space required by the actual content (Variable). This decision impacts random access speed, fragmentation, and the complexity of update operations.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the underlying mechanics of data layout rather than specific database engine syntax.

## Scope
This documentation covers the theoretical and structural foundations of how data is organized at the record and field levels.

> [!IMPORTANT]
> **In scope:**
> * Record-level and field-level storage strategies.
> * Memory alignment and padding mechanics.
> * Metadata overhead for dynamic sizing.
> * Computational complexity of data retrieval.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., MySQL InnoDB vs. PostgreSQL Heap).
> * Hardware-level disk sector geometry.
> * Compression algorithms (though they often result in variable-length output).

## Definitions
| Term | Definition |
|------|------------|
| Fixed-Length | A storage strategy where every record or field occupies a predetermined, constant number of bytes. |
| Variable-Length | A storage strategy where the space occupied depends on the actual size of the data content. |
| Padding | Non-functional data added to a fixed-length field to fill the remaining allocated space. |
| Delimiter | A special character or sequence used to mark the boundary between variable-length fields. |
| Length-Prefix | A metadata header preceding a field that specifies the number of bytes the data occupies. |
| Slotted Page | A common organizational structure for managing variable-length records within a fixed-size block or page. |
| Internal Fragmentation | Wasted space within an allocated block of data, often caused by padding in fixed-length structures. |

## Core Concepts
The fundamental tension in data storage is between **predictability** and **efficiency**.

### Fixed-Length Storage
In fixed-length systems, the location of any record can be calculated using simple arithmetic: `Address = Base_Pointer + (Record_Index * Record_Size)`. This allows for $O(1)$ random access. However, if the data stored is smaller than the allocated size, the remaining space is wasted (Internal Fragmentation).

### Variable-Length Storage
Variable-length systems optimize for space by only storing the bytes present. This requires indirection; the system cannot calculate a record's location without consulting a directory or scanning previous records. This introduces a computational overhead but significantly reduces the storage footprint for sparse or highly varied data.

> [!TIP]
> Think of fixed-length storage like a parking lot with numbered, equal-sized spots: you know exactly where spot #50 is, but a motorcycle wastes most of the spot. Variable-length storage is like parallel parking on a curb: cars take only what they need, but you have to walk down the street to find the fifth car.

## Standard Model
The standard model for modern data systems often involves a hybrid approach known as the **Slotted Page Architecture**.

1.  **Fixed-Length Header:** Every page or block begins with a fixed-length header containing metadata (e.g., checksums, pointers to free space).
2.  **Slot Directory:** A table at the beginning (or end) of the page that stores offsets to the start of each variable-length record.
3.  **Data Payload:** The actual records are stored, often growing from the end of the page toward the beginning.
4.  **Indirection:** To access a record, the system looks up the offset in the fixed-length slot directory and then jumps to the variable-length location.

> [!IMPORTANT]
> This model allows the system to treat the *page* as a fixed-length unit for disk I/O while allowing the *records* within it to be variable-length.

## Common Patterns
### Length-Prefixing (Pascal Style)
The data is preceded by a numerical value indicating the length. This is highly efficient for reading because the system knows exactly how many bytes to pull into memory before processing.

### Delimitation (C-Style)
The data ends with a specific marker (e.g., a null terminator `\0` or a newline `\n`). This saves the overhead of a length-prefix but requires the system to scan every byte to find the end of the field, which is less efficient for large datasets.

### Null Bitmaps
In records with many optional fields, a fixed-length "null bitmap" is used at the start of the record. Each bit represents a field; if the bit is zero, the field is omitted entirely from the variable-length payload, saving significant space.

## Anti-Patterns
### Over-Padding
Allocating a fixed-length field based on the "worst-case scenario" (e.g., a 2000-character field for data that is usually 10 characters) leads to massive internal fragmentation and reduced cache hit rates.

### Excessive Indirection
Creating too many layers of pointers to manage variable-length data can lead to "pointer chasing," where the CPU spends more time fetching addresses than processing actual data.

> [!CAUTION]
> Avoid using variable-length storage for fields that are frequently updated and grow in size. This causes "row migration" or "row chaining," where a record no longer fits in its original slot and must be moved, leaving behind a pointer and doubling the I/O required to read it.

## Edge Cases
*   **Multi-byte Character Sets:** In encodings like UTF-8, a "fixed-length" character limit (e.g., 10 characters) does not translate to a fixed-length byte count. A 10-character string could be anywhere from 10 to 40 bytes.
*   **Zero-Length vs. Null:** Systems must distinguish between a variable-length field that is empty (0 bytes) and one that is logically NULL (non-existent).
*   **Overflow Pages:** When a variable-length record exceeds the size of a standard storage page (e.g., a large BLOB or a very long text string), the system must transition to a linked-list of pages or a B-tree of fragments.

## Related Topics
*   **Data Alignment:** The practice of aligning data on 4-byte or 8-byte boundaries to match CPU architecture, which often introduces padding even in variable-length systems.
*   **Serialization Formats:** Protocols like Protocol Buffers (variable-length) vs. flat binary buffers (fixed-length).
*   **B-Tree Indexing:** How fixed vs. variable keys affect the fan-out and depth of index trees.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |