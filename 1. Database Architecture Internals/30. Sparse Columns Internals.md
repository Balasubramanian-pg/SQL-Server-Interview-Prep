# 30. Sparse Columns Internals

Canonical documentation for [30. Sparse Columns Internals](1. Database Architecture Internals/30. Sparse Columns Internals.md). This document defines concepts, terminology, and standard usage.

## Purpose
The purpose of sparse columns is to optimize storage for data structures where a significant percentage of the attributes contain null or default values. In traditional relational storage, every column—even if null—consumes a fixed amount of space or at least a bit in a null bitmap. Sparse columns address the "wide table" problem, where an entity may have hundreds or thousands of potential attributes, but only a small fraction are populated for any given record.

By shifting the storage overhead from the individual row's fixed-length section to a specialized variable-length overflow area, sparse columns allow for the creation of highly extensible schemas without the traditional performance and storage penalties associated with massive, mostly-empty tables.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the underlying architectural mechanics of sparse storage.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Physical storage mechanics of sparse vs. dense data.
> * Metadata overhead and the "Threshold of Efficiency."
> * Logical representation and interaction via Column Sets.
> * Impact on row structure and page density.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific syntax (e.g., T-SQL or PL/SQL specific commands).
> * Hardware-level disk sector optimization.
> * Non-relational sparse formats (e.g., Parquet or ORC) except where they provide conceptual context.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Sparse Column | A column optimized for null values that consumes no space for NULLs but incurs a small overhead for non-NULL values. |
| Dense Column | A standard column that consumes a fixed or variable amount of space regardless of whether it contains a value. |
| Nullity | The ratio of NULL values to the total number of rows in a specific column. |
| Column Set | A logical, untyped XML or JSON-like representation that aggregates all sparse columns into a single field. |
| Threshold of Efficiency | The specific percentage of nullity at which a sparse column becomes more space-efficient than a dense column. |
| Fixed-Length Section | The portion of a database row reserved for columns that always occupy a predetermined amount of space. |

## Core Concepts

### The Storage Trade-off
The fundamental concept of sparse columns is a trade-off between space and processing overhead. 
* **Dense Storage:** Optimized for read/write speed. The engine knows exactly where a column starts and ends based on an offset.
* **Sparse Storage:** Optimized for space. The engine must parse a specialized "complex column" structure to find the data, which requires more CPU cycles but reduces the physical footprint of the row.

> [!TIP]
> Think of a dense column like a reserved parking spot with a nameplate; the spot is yours even if you aren't there. A sparse column is like a valet service; you only take up space when you arrive, but it takes a little longer to retrieve your car.

### The Threshold of Efficiency
Sparse columns are not a "set and forget" feature. Because non-null values in a sparse column require more metadata (to identify which column the value belongs to) than dense columns, there is a crossover point. If a column is 50% full, sparse storage is usually significantly less efficient than dense storage. Most implementations require a nullity of 90% to 95% to see a net gain in storage efficiency.

## Standard Model
In the standard model for sparse column internals, the database engine modifies the row structure:

1.  **The Fixed Header:** Remains largely unchanged, containing row metadata.
2.  **The Dense Data Region:** Contains all standard columns.
3.  **The Sparse Vector:** A specialized hidden column (often a variable-length blob) at the end of the row. This vector contains a sequence of (ColumnID, Value) pairs.
4.  **The Null Bitmap:** Sparse columns are typically excluded from the standard null bitmap to save bits, as their "nullness" is implied by their absence from the Sparse Vector.

When a query requests a sparse column, the engine locates the Sparse Vector, iterates through the IDs to find the matching ColumnID, and extracts the value. If the ID is not present, the engine returns NULL.

## Common Patterns

### The "Wide Table" Pattern
Used in Content Management Systems (CMS) or Product Information Management (PIM) systems. Instead of using an Entity-Attribute-Value (EAV) table (which is difficult to query and index), developers use a single wide table with hundreds of sparse columns. This maintains a relational structure while allowing for thousands of optional attributes.

### Schema Evolution
Sparse columns allow for adding new attributes to a table without requiring a massive data movement or immediate page reorganization, as the new columns initially occupy no space for existing rows.

## Anti-Patterns

### Sparse-on-Dense
Applying the sparse property to a column that is frequently populated (e.g., a "CreatedDate" column). This results in increased CPU usage for parsing and increased storage size due to the ColumnID overhead.

### Over-Indexing
Creating individual indexes on hundreds of sparse columns. While the storage of the table is optimized, the indexes themselves are often dense (unless filtered), which can negate all storage gains.

> [!CAUTION]
> Avoid using sparse columns in tables where the row size frequently approaches the page limit. The overhead of the sparse vector can occasionally push a row over the limit during an update, causing expensive row-chaining or page splits.

## Edge Cases

*   **Filtered Indexes:** The most efficient way to index a sparse column is via a filtered index (e.g., `WHERE Column IS NOT NULL`). This ensures the index only contains entries for rows that actually have data, mirroring the efficiency of the storage layer.
*   **Data Compression:** Row and page compression can sometimes make dense columns nearly as small as sparse columns. In systems with aggressive compression, the benefits of sparse columns are often diminished.
*   **In-Memory Storage:** Some in-memory engines do not support sparse columns because the pointer-based logic of in-memory structures favors fixed-width offsets for performance.

## Related Topics
*   **Entity-Attribute-Value (EAV) Modeling:** The logical alternative to sparse columns.
*   **Filtered Indexes:** The primary mechanism for indexing sparse data.
*   **Columnstore Indexing:** A different approach to handling wide, sparse data by storing data vertically.
*   **JSON/XML Storage:** Alternative methods for storing semi-structured, optional attributes.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |