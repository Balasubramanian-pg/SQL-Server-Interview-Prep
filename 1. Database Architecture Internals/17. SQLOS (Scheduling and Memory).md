# 17. SQLOS (Scheduling and Memory)

Canonical documentation for [17. SQLOS (Scheduling and Memory)](1. Database Architecture Internals/17. SQLOS (Scheduling and Memory).md). This document defines concepts, terminology, and standard usage.

## Purpose
The SQL Operating System (SQLOS) exists as a specialized, user-mode application layer designed to manage system resources—specifically CPU scheduling and memory allocation—more efficiently than a general-purpose operating system. Database engines require highly predictable, low-latency resource management to handle thousands of concurrent requests. SQLOS abstracts the underlying hardware and host operating system, providing a controlled environment where the database engine can optimize for high throughput, minimize context switching, and manage memory pressure with granular precision.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural patterns of a user-mode operating system layer within a database engine.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Cooperative multitasking and scheduling mechanics.
> * Memory management hierarchies (Clerks, Pools, and Allocators).
> * Synchronization primitives (Spinlocks, Latches, and Semaphores).
> * Resource governance and NUMA (Non-Uniform Memory Access) awareness.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific kernel-mode driver implementations.
> * Physical hardware maintenance or BIOS-level configurations.
> * High-level application code (e.g., specific SQL queries) unless used to illustrate resource consumption.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Scheduler** | A logical structure representing a CPU core that manages the execution of workers. |
| **Worker** | A logical thread managed by the SQLOS that maps to an underlying OS thread. |
| **Task** | A discrete unit of work (e.g., a query execution plan) assigned to a worker. |
| **Quantum** | The fixed duration (typically 4ms) a worker is permitted to run before it must yield control. |
| **Memory Clerk** | An interface used by engine components to request and track memory allocations. |
| **Yielding** | The act of a worker voluntarily giving up the CPU to allow other workers to run. |
| **NUMA Node** | A hardware-defined grouping of processors and memory that provides local, high-speed access. |
| **Latch** | A lightweight synchronization object used to protect internal data structures (e.g., memory pages). |

## Core Concepts
The fundamental philosophy of SQLOS is **Cooperative Multitasking**. Unlike a standard OS that uses preemptive multitasking (where the OS interrupts threads at will), SQLOS relies on workers to voluntarily yield control at specific "safe points."

### The Scheduling Hierarchy
SQLOS organizes work in a strict hierarchy:
1.  **Node:** Represents a physical or virtual NUMA node.
2.  **Scheduler:** Maps to a single logical processor.
3.  **Worker:** The execution vehicle (thread).
4.  **Task:** The actual request being processed.

### Memory Management Layers
Memory is managed through a tiered system to prevent fragmentation and ensure fair distribution:
*   **Memory Nodes:** Align with hardware NUMA nodes to ensure memory locality.
*   **Memory Clerks:** Categorize memory usage (e.g., Buffer Pool, Plan Cache) for monitoring and governance.
*   **Allocators:** The low-level mechanisms that interface with the OS to reserve and commit memory pages.

> [!TIP]
> Think of SQLOS as a "Traffic Controller" in a private city. While the host OS manages the entire country, SQLOS knows the specific timing of every traffic light in its city to ensure that no "delivery truck" (query) gets stuck behind a "slow car" (background task).

## Standard Model
The standard model for SQLOS operations follows the **Run-Wait-Yield** lifecycle:

1.  **Running:** A task is actively executing on a scheduler.
2.  **Suspended:** A task is waiting for a resource (e.g., an I/O completion or a lock). It is moved to a "Wait List."
3.  **Runnable:** A task has everything it needs to run but is waiting for its turn on the scheduler. It sits in a "Runnable Queue" (FIFO).
4.  **Yielding:** When a task reaches the end of its quantum or completes its work, it yields, allowing the next task in the Runnable Queue to move to the Running state.

This model ensures that the database engine maintains a high "Signal-to-Wait" ratio, maximizing CPU utilization while minimizing the overhead of OS-level context switches.

## Common Patterns
*   **Resource Pooling:** Reusing workers and memory objects to avoid the expensive overhead of creation and destruction.
*   **Dynamic Memory Adjustment:** SQLOS monitors system-wide memory pressure and can shrink its internal caches (e.g., dropping clean pages from the buffer pool) to return memory to the host OS.
*   **Affinity Masking:** Binding specific schedulers to specific physical CPUs to prevent "thread migration" across NUMA boundaries, which can degrade performance.

## Anti-Patterns
*   **Long-Running Non-Yielding Tasks:** Operations that perform heavy computation without hitting a yield point, effectively "starving" the scheduler and blocking other tasks.
*   **External Pressure Starvation:** Allowing non-database applications to run on the same host, causing the host OS to forcibly page out SQLOS memory.
*   **Over-Subscription:** Assigning more logical schedulers than there are physical cores, leading to excessive context switching and "scheduler thrashing."

> [!CAUTION]
> Avoid "Preemptive" transitions within critical code paths. When SQLOS must call an external code library (like a DLL), it switches to "Preemptive Mode," which removes the task from SQLOS control and can lead to unpredictable scheduling delays.

## Edge Cases
*   **Hidden Schedulers:** SQLOS often maintains dedicated schedulers for internal system tasks (e.g., Backup/Restore, Log Writer) that are not visible to standard user-task monitoring.
*   **Deadlocked Schedulers:** A rare condition where all workers on a scheduler are waiting for resources held by workers on other schedulers that are themselves blocked, requiring a "Scheduler Monitor" to intervene.
*   **Large Page Allocation:** When configured, SQLOS can bypass standard page-walking by using Large Pages, which improves TLB (Translation Lookaside Buffer) efficiency but prevents the OS from paging that memory to disk.

## Related Topics
*   **12. Concurrency Control:** How SQLOS scheduling interacts with row-level and table-level locking.
*   **15. Buffer Management:** The specific memory clerk responsible for data page caching.
*   **19. Resource Governor:** The policy layer that sits atop SQLOS to limit CPU and Memory for specific workloads.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |