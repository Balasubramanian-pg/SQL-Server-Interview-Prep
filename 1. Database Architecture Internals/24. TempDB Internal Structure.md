# 24. TempDB Internal Structure

Canonical documentation for [24. TempDB Internal Structure](1. Database Architecture Internals/24. TempDB Internal Structure.md). This document defines concepts, terminology, and standard usage.

## Purpose
The TempDB internal structure exists to provide a high-performance, global workspace for transient data operations. It addresses the need for a non-persistent storage area where the system can manage intermediate result sets, internal worktables, and row versioning without the overhead of full transaction logging required by permanent databases.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural requirements of temporary storage engines.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Allocation mechanisms (PFS, GAM, SGAM)
> * Internal object types (Worktables, Workfiles)
> * Metadata management and contention mechanics
> * Version store architecture
> * Lifecycle of temporary objects

> [!WARNING]
> **Out of scope:**
> * Specific hardware vendor configurations
> * Application-level T-SQL syntax for temporary tables
> * Third-party monitoring tool interfaces

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **PFS (Page Free Space)** | A bitmap page that tracks the allocation status and approximate free space available on individual pages. |
| **GAM (Global Allocation Map)** | A structure that tracks which extents have been allocated for any use. |
| **SGAM (Shared Global Allocation Map)** | A structure that tracks extents currently used as "mixed extents" with at least one unused page. |
| **Version Store** | A collection of data pages used to support row versioning for isolation levels and online operations. |
| **Worktable** | An internal temporary object created by the engine for spooling, joins, or sorting operations. |
| **Metadata Contention** | A bottleneck occurring when multiple threads attempt to modify system tables or allocation maps simultaneously. |

## Core Concepts
The internal structure of a temporary database is optimized for high-frequency DDL (Data Definition Language) and DML (Data Manipulation Language) operations. Unlike permanent databases, the internal structure is rebuilt upon every system restart.

### The Global Scratchpad
TempDB acts as a shared resource for all sessions. Its internal structure must handle concurrent requests from disparate processes, necessitating a highly efficient latching and locking mechanism.

### Allocation Maps
The engine manages space through a hierarchy of allocation pages. Because temporary objects are created and destroyed rapidly, the efficiency of the PFS, GAM, and SGAM pages is critical to overall system throughput.

> [!TIP]
> Think of TempDB as a high-speed whiteboard in a busy office. While everyone can write on it, the "eraser" (system restart) clears everything, and the "grid" (allocation maps) ensures no two people write in the same square at the same time.

## Standard Model
The standard model for a temporary storage engine involves a multi-file architecture designed to minimize allocation bottlenecking.

1.  **Uniform Extent Allocation:** Modern implementations prioritize allocating full extents (8 pages) to objects rather than single pages to reduce the overhead on SGAM pages.
2.  **Proportional Fill:** When multiple data files exist, the engine distributes data across them based on the free space in each file, ensuring balanced I/O.
3.  **Metadata Caching:** To reduce contention on system tables, the engine caches temporary table metadata, allowing for the reuse of temporary object structures without frequent updates to the underlying system catalog.
4.  **Minimal Logging:** While operations are logged to support rollbacks within a session, the log is not used for recovery, allowing for more aggressive write-ahead logging optimizations.

## Common Patterns
*   **File Parallelism:** Configuring the number of data files to match the logical processor count (up to a specific threshold, typically 8) to distribute the load across multiple PFS and GAM pages.
*   **Pre-allocation:** Sizing the temporary data and log files to their maximum expected size to prevent "autogrow" events, which are synchronous and performance-intensive.
*   **Instant File Initialization:** Allowing the engine to skip zeroing out data files, significantly speeding up file creation and growth.

## Anti-Patterns
*   **Single Data File on High-Core Systems:** Using only one data file leads to "latch contention" on the single PFS/GAM page, effectively serializing object creation.
*   **Long-Running Transactions with Versioning:** Keeping transactions open while using row versioning prevents the cleanup of the Version Store, leading to rapid disk exhaustion.
*   **Excessive DDL in TempDB:** Frequent creation and dropping of small temporary tables instead of using table variables or reusing existing structures can overwhelm the metadata system.

> [!CAUTION]
> Avoid circular dependencies where a process in TempDB triggers an event that requires more TempDB space than is available, leading to a system-wide "Stall" or "Out of Space" condition.

## Edge Cases
*   **Version Store Bloat:** In scenarios involving Snapshot Isolation, the version store can grow to consume all available space if a single "ghost" transaction remains active, even if that transaction is idle.
*   **Metadata Latch Contention (PAGELATCH_UP):** On extremely high-concurrency systems, even with multiple files, the system may experience contention on the system catalog (e.g., `sysobjvalues`), requiring specific trace flags or engine updates to enable metadata optimization.
*   **Mixed Extent Exhaustion:** In legacy configurations, the exhaustion of mixed extents can cause failures even when significant free space exists in uniform extents.

## Related Topics
*   **Transaction Log Architecture:** How TempDB logging differs from permanent database logging.
*   **Memory-Optimized Metadata:** The transition of TempDB system tables to non-durable memory-optimized tables.
*   **Buffer Pool Management:** How TempDB pages are prioritized or evicted from the global buffer cache.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |