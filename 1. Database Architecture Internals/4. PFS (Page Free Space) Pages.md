# 4. PFS (Page Free Space) Pages

Canonical documentation for [4. PFS (Page Free Space) Pages](1. Database Architecture Internals/4. PFS (Page Free Space) Pages.md). This document defines concepts, terminology, and standard usage.

## Purpose
The primary purpose of Page Free Space (PFS) pages is to provide a high-performance mechanism for tracking the availability of storage space and the allocation status of individual pages within a database file. In a structured storage system, locating a page with sufficient free space to accommodate a new record or an updated record is a frequent operation. Without a dedicated tracking structure, the system would be forced to scan data pages sequentially, leading to significant I/O overhead and latency.

PFS pages solve the "allocation search problem" by maintaining a compact, byte-mapped representation of the state of a large range of pages, allowing the storage engine to quickly identify suitable targets for data insertion.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural necessity of space-tracking bitmaps in block-based storage engines.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The structural organization of PFS metadata.
> * The granularity of free space tracking (e.g., percentage-based vs. exact).
> * The role of PFS in page allocation and deallocation workflows.
> * Tracking of specialized page states, such as ghost records or IAM status.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-proprietary binary offsets or internal hex codes.
> * Hardware-level disk sector management.
> * File system-level allocation (NTFS/APFS/ext4) beyond the database file boundary.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| PFS Page | A specialized metadata page that records the allocation status and amount of free space for a specific range of subsequent pages. |
| Allocation Status | A flag indicating whether a page is currently assigned to a specific database object (e.g., a table or index). |
| Ghost Record | A record that has been logically deleted but physically remains on the page until a cleanup process occurs. |
| Page Interval | The fixed number of data pages that a single PFS page is responsible for tracking. |
| Byte-map | A data structure where a single byte (8 bits) is used to represent the state of a single page. |

## Core Concepts
The fundamental idea behind PFS is the decoupling of data storage from space management. By centralizing the "fullness" metadata, the storage engine can make intelligent decisions about where to place data without reading the data pages themselves.

**1. The Byte-Map Structure**
Unlike bitmapped structures that only track binary states (allocated/unallocated), PFS pages typically use a byte-map. This allows for a richer set of metadata per page, including:
*   The approximate percentage of free space (e.g., 0%, 50%, 80%, 95%, 100%).
*   Whether the page contains "ghost" records.
*   Whether the page is an IAM (Index Allocation Map) page.
*   Whether the page is allocated to an object.

**2. Fixed Intervals**
PFS pages appear at regular, predictable intervals within a data file. This allows the storage engine to calculate the location of the relevant PFS page for any given data page using simple arithmetic, rather than a lookup table.

> [!TIP]
> Think of a PFS page as the "Directory Board" in a large hotel. Instead of walking down every hallway and knocking on every door to find a vacant room, a guest (the data) checks the board at the elevator to see which rooms are currently empty or partially occupied.

## Standard Model
In the standard model of space management, a PFS page is the first page of a file (or follows a file header) and repeats every $N$ pages (where $N$ is typically determined by the page size and the size of the byte-map).

*   **Mapping:** Each byte in the PFS page corresponds to exactly one page in the data file.
*   **Update Trigger:** When a data page undergoes an operation that significantly changes its free space (e.g., an `INSERT`, `UPDATE`, or `DELETE`), the storage engine synchronously or asynchronously updates the corresponding byte in the PFS page.
*   **Search Algorithm:** When a new row requires a home, the engine scans the PFS byte-map for the first page that meets the minimum space requirement.

## Common Patterns
*   **Proportional Fill:** When multiple files exist in a filegroup, the engine uses PFS data to prioritize files with more free space, ensuring even distribution across physical media.
*   **Round-Robin Allocation:** To reduce contention on a single PFS page, some engines implement a round-robin approach, starting the search for free space at different offsets within the PFS interval.
*   **Ghost Cleanup:** The PFS page acts as a trigger for background "ghost cleanup" tasks. If a PFS byte indicates the presence of ghost records, a background process knows it can reclaim space on that specific page.

## Anti-Patterns
*   **PFS Contention (Hotspots):** In high-concurrency environments with frequent small inserts, multiple threads may attempt to update the same PFS page simultaneously. This leads to latch contention and bottlenecks.
*   **Over-Granular Tracking:** Attempting to track free space down to the exact byte in the PFS page. This causes excessive metadata updates for every minor change, negating the performance benefits of the structure.
*   **Ignoring PFS during Bulk Loads:** Performing massive data ingestions without updating PFS metadata can lead to "phantom" free space, where the engine believes pages are full when they are actually empty.

> [!CAUTION]
> Avoid designs where the PFS update is decoupled from the transaction log without a recovery mechanism; otherwise, the space map may become desynchronized from the actual data state after a system crash.

## Edge Cases
*   **Large Object (LOB) Storage:** Pages containing LOB data (like BLOBs or CLOBs) often use different allocation logic. The PFS may mark these pages as "Full" regardless of actual byte count because they cannot be shared with other records.
*   **Compressed Pages:** When page-level compression is active, the "free space" reported in the PFS is an estimate. A page might appear to have space, but a new record might fail to fit if it does not compress as well as existing data.
*   **File Growth Events:** When a database file grows, new PFS pages must be initialized immediately to cover the newly allocated physical space before any data can be written to those pages.

## Related Topics
*   **GAM (Global Allocation Map):** Tracks extent allocation rather than individual page free space.
*   **IAM (Index Allocation Map):** Maps pages or extents to a specific table or index.
*   **Extent Management:** The grouping of pages (usually 8) for more efficient allocation.
*   **Write-Ahead Logging (WAL):** The mechanism ensuring that changes to PFS pages are durable.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |