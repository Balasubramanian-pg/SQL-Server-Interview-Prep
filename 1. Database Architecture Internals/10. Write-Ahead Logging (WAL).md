# 10. Write Ahead Logging (WAL)

Canonical documentation for 10. Write Ahead Logging (WAL). This document defines concepts, terminology, and standard usage.

## Purpose
Write Ahead Logging (WAL) is a fundamental family of techniques for providing atomicity and durability (two of the ACID properties) in database systems and distributed systems. The primary purpose of WAL is to ensure that no data modifications are lost due to system failures and to provide a mechanism for recovering a system to a consistent state.

By recording all changes in a sequential log before those changes are applied to the actual data files (the "state"), the system can reconstruct the intended state even if a crash occurs during the process of updating the primary storage. This decouples the latency of ensuring durability from the complexity of updating complex data structures on disk.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural pattern rather than specific software configurations.

## Scope
This document covers the theoretical underpinnings, operational mechanics, and structural requirements of the WAL pattern.

> [!IMPORTANT]
> **In scope:**
> * Core functionality of sequential logging.
> * The relationship between volatile memory (RAM) and persistent storage.
> * Recovery procedures (Redo/Undo logic).
> * Checkpointing mechanisms.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., PostgreSQL WAL, SQLite WAL mode, InnoDB Redo Logs).
> * Hardware-specific optimizations (e.g., NVMe-specific driver tuning).
> * File system-level journaling, except where used as a comparative example.

## Definitions
| Term | Definition |
|------|------------|
| Log Sequence Number (LSN) | A unique, monotonically increasing identifier assigned to each record in the log. |
| Dirty Page | A data block in memory that has been modified but not yet written to persistent data storage. |
| Checkpoint | The process of synchronizing dirty pages in memory with the data files on disk to truncate the log. |
| Redo | The process of replaying log records to ensure all committed transactions are reflected in the data files. |
| Undo | The process of reversing changes from uncommitted transactions found in the log during recovery. |
| Flush/Sync | The operation of forcing data from volatile OS buffers to physical persistent media. |

## Core Concepts
The fundamental principle of WAL is that **all modifications must be written to a log on persistent storage before they are applied to the main data store.**

### The Sequential Advantage
Updating a database often involves changing data in multiple locations (indexes, tables, metadata). Writing these changes directly to their final locations on disk requires "random I/O," which is significantly slower than "sequential I/O." WAL converts these disparate updates into a single sequential stream of log entries, which is much faster to persist.

### The Durability Guarantee
A transaction is considered "committed" only when its log records have been successfully flushed to persistent storage. The actual data files may be updated much later.

> [!TIP]
> Think of WAL like a bookkeeperâ€™s ledger. Instead of updating the final balance sheet every time a penny moves (which is slow and prone to error if the bookkeeper is interrupted), the bookkeeper quickly scribbles every transaction into a chronological diary. If the office burns down but the diary survives, the final balance sheet can be perfectly reconstructed.

## Standard Model
The standard model for WAL operations follows a strict sequence of events to maintain data integrity:

1.  **Transaction Initiation:** A change request is received.
2.  **Log Entry Creation:** A record describing the change (the "before" and "after" image or the operation itself) is constructed in memory.
3.  **Log Flush:** The log entry is written to persistent storage. The system must wait for a hardware acknowledgment that the data is "on the platter."
4.  **Memory Update:** The data pages in the system's cache (RAM) are updated.
5.  **Commit Acknowledgment:** The user is notified that the transaction is successful.
6.  **Asynchronous Data Update:** At a later time, the "dirty pages" in RAM are written to the main data files.

### Recovery Procedure
When a system restarts after a failure, it performs the following:
*   **Analysis Phase:** Identifies which pages in the data files are "dirty" and which transactions were active at the time of failure.
*   **Redo Phase:** Replays all logged operations from the last known checkpoint to ensure the data files reflect all committed changes.
*   **Undo Phase:** Reverses any changes in the data files that belonged to transactions that never successfully committed.

## Common Patterns
*   **Physical Logging:** Storing the exact byte-level changes of the data pages. This is robust but results in large logs.
*   **Logical Logging:** Storing the high-level operations (e.g., "Update Salary by 10%"). This results in smaller logs but requires deterministic execution.
*   **Physiological Logging:** A hybrid approach where the log identifies a specific page but describes the change logically within that page.
*   **Log Archiving:** Moving old WAL segments to long-term storage (e.g., S3 or Tape) to allow for Point-in-Time Recovery (PITR).

## Anti-Patterns
*   **Synchronous Data Writing:** Writing to the data file at the same time as the log. This negates the performance benefits of WAL and increases I/O contention.
*   **Log-on-Data Contention:** Placing the WAL files on the same physical disk spindle/bus as the data files. Since WAL is sequential and Data is random, the disk head will thrash between the two, destroying performance.
*   **Infinite Logs:** Failing to implement a checkpointing strategy, leading to a log that grows until it consumes all disk space and makes recovery times unacceptably long.

> [!CAUTION]
> Never disable the "flush to disk" (fsync) requirement for WAL in a production environment unless the data is transient. Doing so creates a window where a "committed" transaction can be lost if the operating system or hardware fails.

## Edge Cases
*   **Torn Writes:** A failure occurring exactly while a log block is being written, resulting in a partial or corrupted log entry. This is usually mitigated by checksums or "double-write" buffers.
*   **Disk Full during WAL Flush:** If the log cannot be written, the entire database must halt. Unlike data files, WAL exhaustion is a "stop-the-world" event for write operations.
*   **Clock Skew:** In distributed WAL systems, relying on system timestamps for log ordering rather than LSNs can lead to data divergence.

## Related Topics
*   **ACID Properties:** The theoretical framework WAL helps implement.
*   **Checkpointing:** The process that manages WAL size.
*   **Two-Phase Commit (2PC):** How WAL is coordinated across multiple distributed nodes.
*   **Log-Structured Merge-Trees (LSM):** An alternative storage architecture that treats the entire data store as a log.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |