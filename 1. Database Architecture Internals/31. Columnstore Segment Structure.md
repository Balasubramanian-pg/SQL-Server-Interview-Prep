# 31. Columnstore Segment Structure

Canonical documentation for [31. Columnstore Segment Structure](1. Database Architecture Internals/31. Columnstore Segment Structure.md). This document defines concepts, terminology, and standard usage.

## Purpose
The Columnstore Segment Structure exists to optimize data storage for analytical processing (OLAP). Unlike traditional row-based storage, which stores all data for a single record contiguously, columnstore structures group data by column. This architectural shift addresses the need for high-ratio data compression and rapid retrieval of specific attributes across millions or billions of rows. By isolating column data into discrete segments, systems can minimize I/O by reading only the data necessary for a specific query.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the logical and physical imperatives of columnar storage units.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The logical hierarchy of rowgroups and segments.
> * Internal segment components (dictionaries, bitmasks, and data blocks).
> * Metadata requirements for segment management.
> * Compression and encoding principles within a segment.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., MSSQL, Snowflake, ClickHouse).
> * Specific file formats (e.g., Parquet, ORC) except as examples of the model.
> * Hardware-level disk sector management.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Rowgroup | A logical grouping of a fixed number of rows (typically ~1 million) that are processed together. |
| Segment | The physical unit of storage containing the data for a single column within a specific rowgroup. |
| Dictionary | A secondary structure within a segment that maps unique values to integer codes to reduce storage size. |
| Delta Store | A temporary row-based structure used to stage incoming data before it is compressed into segments. |
| Bitmask | A structure used within a segment to track the presence of NULL values or deleted rows. |
| Encoding | The process of converting raw data into a more compact format (e.g., Delta encoding, RLE). |

## Core Concepts
The fundamental idea behind a columnstore segment is the transformation of a two-dimensional table into a series of one-dimensional arrays.

**The Hierarchy of Storage**
A table is divided horizontally into **Rowgroups**. Each Rowgroup is then divided vertically into **Segments**. Therefore, a segment represents the intersection of one column and one rowgroup.

**Data Locality and I/O Efficiency**
Because segments contain only data for a single column, a query selecting only two columns from a hundred-column table only needs to touch the segments associated with those two columns. This drastically reduces the "data tax" paid during disk-to-memory transfers.

> [!TIP]
> Think of a rowstore as a library where every book contains one full biography. To find the birth dates of 1,000 people, you must pull 1,000 books. A columnstore is like a library where one book contains only names, another contains only birth dates, and another contains only occupations. To find birth dates, you only pull the "Birth Date" book.

## Standard Model
The standard model for a columnstore segment consists of three primary layers:

1.  **Segment Header (Metadata):**
    *   Contains the column ID and rowgroup ID.
    *   Stores statistical summaries (Min/Max values, null count) used for "Segment Skipping" during query execution.
    *   Identifies the encoding and compression algorithms applied to the data block.

2.  **Dictionary (Optional):**
    *   Used for columns with low to medium cardinality.
    *   Stores unique values once; the data block then stores only the index of the value in the dictionary.

3.  **Data Block:**
    *   The compressed payload of column values.
    *   Values are typically stored in a highly compressed state using techniques like Run-Length Encoding (RLE), Bit-packing, or Frame of Reference (FOR) encoding.

## Common Patterns
*   **Segment Skipping (Pruning):** Using the Min/Max metadata in the segment header to bypass entire segments that cannot possibly contain the requested data.
*   **Vectorized Execution:** Processing segments in batches of values (vectors) rather than one value at a time, taking advantage of modern CPU SIMD (Single Instruction, Multiple Data) instructions.
*   **Clustered Ordering:** Sorting the data by a specific column before segment creation to maximize the effectiveness of segment skipping and RLE compression.

## Anti-Patterns
*   **Trickle Inserts:** Inserting data in very small batches (e.g., one row at a time). This leads to "fragmented" segments or an over-reliance on the Delta Store, negating the performance benefits of the columnstore.
*   **High-Cardinality Overload:** Using columnstore segments for columns with unique values (like GUIDs or high-precision timestamps) where dictionary encoding is ineffective and compression ratios are poor.
*   **Frequent Updates:** Modifying data within a compressed segment is computationally expensive, as segments are generally immutable. Updates usually require marking a row as deleted and inserting a new version in the Delta Store.

> [!CAUTION]
> Avoid over-partitioning tables. If partitions are too small, rowgroups will not reach their optimal size (usually ~1 million rows), leading to "thin" segments that suffer from poor compression and increased metadata overhead.

## Edge Cases
*   **NULL-Heavy Columns:** If a column is mostly NULLs, the segment structure must efficiently represent these gaps without consuming physical space, typically through a compressed bitmask.
*   **Wide Metadata:** In tables with thousands of columns, the metadata for the segments themselves can become a bottleneck if not managed or cached properly.
*   **Schema Evolution:** Adding or dropping columns requires the system to manage segments that may not exist for older rowgroups, necessitating a robust "missing segment" logic in the execution engine.

## Related Topics
*   **32. Columnar Compression Algorithms:** Detailed look at RLE, Dictionary, and Bit-packing.
*   **15. Data Partitioning Strategies:** How horizontal partitioning interacts with rowgroup formation.
*   **44. Vectorized Query Execution:** How engines process segments at the CPU level.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |