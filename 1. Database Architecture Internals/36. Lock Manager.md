# 36. Lock Manager

Canonical documentation for [36. Lock Manager](1. Database Architecture Internals/36. Lock Manager.md). This document defines concepts, terminology, and standard usage.

## Purpose
The Lock Manager is a fundamental architectural component responsible for coordinating access to shared resources in concurrent systems. Its primary purpose is to ensure data integrity and consistency by preventing conflicting operations from occurring simultaneously on the same resource. 

In environments where multiple processes, threads, or transactions compete for limited resources (such as memory blocks, database rows, or file handles), the Lock Manager acts as an arbiter. It maintains a registry of current locks, evaluates incoming requests against existing permissions, and manages the queuing of blocked entities.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the logical requirements of lock management rather than specific software vendor internals.

## Scope
This documentation covers the theoretical framework and operational requirements of a centralized or distributed Lock Manager.

> [!IMPORTANT]
> **In scope:**
> * Core functionality: Requesting, granting, and releasing locks.
> * Lock modes and compatibility matrices.
> * Deadlock detection and prevention strategies.
> * Lock granularity and hierarchy management.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., SQL Server's LCK_M_X or PostgreSQL's Heavyweight Locks).
> * Hardware-level atomic instructions (e.g., Compare-and-Swap), except where they serve as building blocks for a higher-level Lock Manager.

## Definitions
| Term | Definition |
|------|------------|
| Resource | The entity being protected (e.g., a data page, a record, or a system object). |
| Lock | A synchronization primitive representing a granted permission to access a resource. |
| Requestor | The entity (transaction, thread, or process) seeking access to a resource. |
| Lock Mode | The level of access requested (e.g., Shared, Exclusive, Intent). |
| Compatibility Matrix | A truth table defining which lock modes can coexist on the same resource. |
| Deadlock | A state where two or more requestors are perpetually blocked, each waiting for a resource held by the other. |
| Lock Escalation | The process of converting many fine-grained locks into a single coarse-grained lock to reduce memory overhead. |

## Core Concepts

### Lock Modes and Compatibility
The Lock Manager operates on the principle of compatibility. Not all concurrent accesses are harmful. For example, multiple requestors can typically read a resource simultaneously without conflict, but only one should be allowed to modify it.

*   **Shared (S):** Allows concurrent reads.
*   **Exclusive (X):** Grants sole access for modification; no other locks allowed.
*   **Intent Locks (IS, IX):** Used in hierarchical locking to indicate that a requestor holds or intends to hold locks at a lower level of the hierarchy.

> [!TIP]
> Think of a Lock Manager as a library librarian. Multiple people can read copies of the same book (Shared), but only one person can check out the original manuscript to edit it (Exclusive). Intent locks are like a sign on the library door saying "Someone is currently editing a book in here," preventing the entire library from being closed for maintenance while that person is working.

### The Lock Table
The Lock Manager maintains an internal data structure, often a hash table, where the key is the Resource ID and the value is a list of granted locks and a queue of pending requests.

## Standard Model
The standard model for a Lock Manager follows a Request-Grant-Release lifecycle:

1.  **Request:** A requestor asks for a specific lock mode on a resource.
2.  **Evaluation:** The Lock Manager checks the compatibility matrix.
    *   If compatible, the lock is **Granted**.
    *   If incompatible, the requestor is placed in a **Wait Queue** and suspended.
3.  **Release:** When the requestor finishes, it notifies the Lock Manager.
4.  **Promotion:** Upon release, the Lock Manager evaluates the Wait Queue and grants the lock to the next eligible requestor.

### Deadlock Management
Since Lock Managers allow resources to be held while waiting for others, deadlocks are inevitable. The standard model employs two primary strategies:
*   **Detection:** Periodically scanning the "Wait-For" graph for cycles and terminating one of the participants.
*   **Prevention:** Using timeouts or ordering resource acquisition to ensure cycles cannot form.

## Common Patterns

### Two-Phase Locking (2PL)
A protocol ensuring serializability. It consists of a "Growing Phase" (acquiring locks) and a "Shrinking Phase" (releasing locks). Once a lock is released, no new locks can be acquired by that transaction.

### Strict Two-Phase Locking (S2PL)
A variation where all Exclusive locks are held until the transaction commits or aborts. This prevents "dirty reads" and cascading rollbacks.

### Lock Partitioning
In high-concurrency systems, the Lock Manager itself can become a bottleneck. Partitioning the lock table across multiple CPUs or nodes reduces contention on the Lock Manager's internal structures.

## Anti-Patterns

### Long-Running Transactions with Exclusive Locks
Holding an Exclusive lock for an extended duration (e.g., awaiting user input) starves other requestors and leads to system-wide throughput degradation.

### Manual Lock Management
Allowing application code to manually acquire and release locks without a structured protocol (like 2PL) often leads to orphaned locks or inconsistent state.

> [!CAUTION]
> Avoid "Lock Convoy" scenarios where multiple threads of equal priority frequently contend for the same lock, causing the OS to spend more time context switching than performing useful work.

## Edge Cases

### Lock Conversion (Upgrading/Downgrading)
A requestor holding a Shared lock may request an upgrade to an Exclusive lock. If another requestor also holds a Shared lock on that same resource, a "Conversion Deadlock" can occur if both try to upgrade simultaneously.

### Starvation
A requestor asking for an Exclusive lock might be perpetually blocked if a continuous stream of new Shared lock requests is granted. Modern Lock Managers implement "fairness" by blocking new Shared requests if an Exclusive request is already waiting in the queue.

### Distributed Lock Management (DLM)
In a distributed system, there is no single memory space. The Lock Manager must communicate across a network, introducing the "Split-Brain" problem where two nodes might believe they both hold an Exclusive lock due to a network partition.

## Related Topics
*   **Concurrency Control:** The broader field of managing simultaneous operations.
*   **Isolation Levels:** How the Lock Manager's behavior translates to data visibility (e.g., Read Committed vs. Serializable).
*   **Optimistic Concurrency Control (OCC):** An alternative to locking that checks for conflicts only at the time of commit.
*   **Semaphores and Mutexes:** Lower-level synchronization primitives used to implement Lock Managers.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-11 | Initial AI-generated canonical documentation |