# 4. Unique Indexes and Constraints

Canonical documentation for [4. Unique Indexes and Constraints](4. Indexing Deep Dive/4. Unique Indexes and Constraints.md). This document defines concepts, terminology, and standard usage.

## Purpose
The primary purpose of unique indexes and constraints is to ensure data integrity by preventing the insertion of duplicate values within a specified set of attributes. They serve as a foundational mechanism for enforcing business rules at the data layer, ensuring that identifiers remain distinct and that relationships between entities are reliable.

Beyond integrity, unique indexes provide a performance optimization path. By maintaining a sorted or hashed structure of unique values, the system can locate specific records with high efficiency, typically reducing search complexity from linear to logarithmic or constant time.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the logical and structural requirements of uniqueness rather than specific syntax.

## Scope
This documentation covers the theoretical and structural application of uniqueness within data systems.

> [!IMPORTANT]
> **In scope:**
> * Logical enforcement of data uniqueness.
> * The relationship between constraints (rules) and indexes (structures).
> * Multi-column (composite) uniqueness.
> * Handling of nullability within unique sets.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific SQL or NoSQL syntax.
> * Performance tuning for specific hardware configurations.
> * Non-unique secondary indexes.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Unique Constraint | A declarative rule that prevents duplicate values in one or more columns. |
| Unique Index | A physical data structure that enforces uniqueness and optimizes data retrieval. |
| Natural Key | A unique identifier derived from existing real-world data (e.g., Social Security Number). |
| Surrogate Key | A unique identifier generated by the system with no intrinsic meaning (e.g., UUID, Auto-increment ID). |
| Composite Uniqueness | A requirement where the combination of values across multiple columns must be unique. |
| Predicate Uniqueness | Uniqueness enforced only on a subset of data that meets a specific condition (also known as a Filtered Index). |

## Core Concepts
The fundamental concept of uniqueness relies on the distinction between the **Logical Constraint** and the **Physical Index**.

**The Constraint (The "What")**
A constraint is a functional requirement. It states: "No two records in this collection may share the same value for Attribute X." It is a contract between the data consumer and the data provider.

**The Index (The "How")**
An index is the implementation mechanism. To efficiently check if a value already exists during an insertion or update, the system maintains a specialized structure (usually a B-Tree or Hash Map). Without an index, the system would be forced to perform a full scan of the dataset to verify uniqueness, which is computationally expensive.

> [!TIP]
> Think of a Unique Constraint as a "No Trespassing" sign (the rule) and the Unique Index as the physical fence (the enforcement mechanism) that makes trespassing physically difficult or impossible.

## Standard Model
In the standard model of data management, a unique constraint is automatically supported by a unique index. When a user defines a unique constraint, the underlying system generates an index to facilitate the enforcement of that rule.

1.  **Validation on Write:** Every insert or update operation triggers a lookup in the unique index.
2.  **Conflict Resolution:** If the value exists, the operation is rejected, preserving the integrity of the dataset.
3.  **Atomic Enforcement:** The check and the write must occur within the same atomic transaction to prevent race conditions.

## Common Patterns
*   **Single-Column Uniqueness:** The most common pattern, used for primary identifiers or alternate keys (e.g., an email address in a user table).
*   **Composite Uniqueness:** Used when the uniqueness depends on a relationship. For example, in a "Classroom" table, the combination of `Building_ID` and `Room_Number` must be unique, even if `Room_Number` repeats across different buildings.
*   **Partial Uniqueness:** Enforcing uniqueness only for "Active" records. This allows historical or "soft-deleted" records to contain duplicates while ensuring the current live data remains unique.

## Anti-Patterns
*   **Application-Level Uniqueness Only:** Attempting to enforce uniqueness solely through application logic (e.g., checking for existence before inserting). This leads to race conditions where two concurrent processes both find the value missing and both insert it simultaneously.
*   **Over-Indexing:** Applying unique indexes to columns with low cardinality or columns that are frequently updated but rarely searched. This increases the overhead of every write operation.
*   **Using Uniqueness for Logic:** Relying on a unique constraint violation to drive complex application workflows rather than validating data state.

> [!CAUTION]
> Avoid relying on application-level checks for uniqueness in distributed systems. Without a centralized constraint at the data layer, data corruption via duplicates is statistically inevitable.

## Edge Cases
*   **Null Values:** The treatment of `NULL` varies by standard. In the SQL standard, `NULL` represents an unknown value; therefore, multiple `NULL` values are often allowed in a unique column because one "unknown" is not necessarily equal to another "unknown." However, some systems treat `NULL` as a distinct value and allow only one.
*   **Case Sensitivity:** In many systems, "Alpha" and "alpha" are treated as unique values. If the business requirement demands case-insensitive uniqueness, the index must be functional (based on a lowercase transformation) or the collation must be set accordingly.
*   **Deferred Constraints:** Some systems allow unique constraints to be violated temporarily during a transaction, provided the data is unique by the time the transaction is committed.

## Related Topics
*   **Primary Keys:** A specific type of unique constraint that also prohibits null values.
*   **Foreign Keys:** Constraints that reference unique indexes in other tables to maintain referential integrity.
*   **Index Fragmentation:** The physical degradation of an index over time due to frequent inserts and deletes.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |