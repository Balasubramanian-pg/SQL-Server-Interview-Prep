# 15. Indexing for Foreign Keys

Canonical documentation for [15. Indexing for Foreign Keys](4. Indexing Deep Dive/15. Indexing for Foreign Keys.md). This document defines concepts, terminology, and standard usage.

## Purpose
The primary purpose of indexing foreign keys is to optimize the performance of relational database operations and ensure the efficiency of referential integrity constraints. While most database systems automatically create an index for Primary Keys, they rarely do so automatically for Foreign Keys. 

This topic addresses the performance gap created when child tables are queried in relation to parent tables, and the overhead incurred during data modification (specifically deletions or updates to parent records) that require the system to scan child tables to validate constraints.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the relational model rather than specific SQL dialects.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The relationship between foreign key constraints and index structures.
> * Performance implications for JOIN operations and referential integrity checks.
> * Locking contention and concurrency issues related to unindexed foreign keys.
> * Strategies for composite and partial indexing of foreign keys.

> [!WARNING]
> **Out of scope:**
> * Specific syntax for creating indexes in individual database engines (e.g., MySQL, PostgreSQL, Oracle).
> * General index tuning not related to foreign key relationships.
> * Non-relational (NoSQL) data modeling.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Foreign Key (FK) | A column or group of columns in a table that provides a link between data in two tables, acting as a cross-reference. |
| Parent Table | The table containing the candidate key (usually the Primary Key) being referenced by a foreign key. |
| Child Table | The table containing the foreign key that references a parent table. |
| Referential Integrity | A property of data stating that all its references are valid; every foreign key value must exist in the parent table. |
| Full Table Scan | A retrieval method where the database engine must read every row in a table to find relevant data. |
| Cascading Action | An operation (UPDATE or DELETE) that propagates from a parent table to associated rows in a child table. |

## Core Concepts
The fundamental concept of indexing foreign keys rests on the asymmetry of relational lookups. While a foreign key points to a primary key (which is indexed), the reverse path—finding all child records for a specific parent—is not inherently optimized.

### The Lookup Asymmetry
In a standard one-to-many relationship, finding the "Parent" of a "Child" is fast because the Parent's Primary Key is indexed. However, finding all "Children" of a "Parent" requires searching the child table. Without an index on the foreign key column, the database must perform a full table scan of the child table.

### Referential Integrity Overhead
When a row in a parent table is deleted or its primary key is updated, the database must ensure that no orphaned records remain in the child table. To perform this check, the engine queries the child table for the value being removed. If the foreign key is unindexed, every deletion in the parent table triggers a full scan of the child table.

> [!TIP]
> Think of a library: The "Books" (Child) have a "Category ID" (Foreign Key) pointing to "Categories" (Parent). If you want to find the name of a book's category, you look at the Category index. But if you want to find all books in "History," and the books aren't grouped by category on the shelf, you have to check every single book in the library one by one.

## Standard Model
The standard model for indexing foreign keys suggests that **most foreign keys should be indexed**, but the index type should be chosen based on the access pattern.

1.  **Single-Column Index:** The most common approach where a B-Tree index is applied directly to the foreign key column.
2.  **Composite Index:** Including the foreign key as the leading column in a multi-column index. This is effective when queries frequently filter by the foreign key and another attribute (e.g., `WHERE customer_id = X AND status = 'ACTIVE'`).
3.  **Covering Index:** An index that includes the foreign key and other columns required by frequent queries, allowing the database to satisfy the query entirely from the index.

## Common Patterns
*   **Join Optimization:** Indexing foreign keys to speed up `JOIN` operations, as the foreign key is almost always the join predicate.
*   **Delete/Update Performance:** Proactively indexing foreign keys in systems with high churn in parent tables to prevent performance degradation during maintenance.
*   **Preventing Table Locks:** In some database architectures, updating a parent table requires a share-lock on the child table. If the foreign key is unindexed, this lock may escalate or persist longer, causing concurrency bottlenecks.

## Anti-Patterns
*   **The "Index Everything" Fallacy:** Automatically indexing every foreign key without considering write overhead. In tables with massive insert volume and rare parent deletions/joins, the cost of maintaining the index may outweigh the benefits.
*   **Redundant Indexing:** Creating a single-column index on a foreign key when that foreign key is already the *leading* column of an existing composite index.
*   **Ignoring Low-Cardinality Columns:** Failing to index a foreign key because it has few unique values. Even with low cardinality, an index can often prevent a full table scan during referential integrity checks.

> [!CAUTION]
> Avoid creating indexes where the foreign key is a trailing column in a composite index if the primary goal is to optimize parent-table deletions. Most database engines cannot use an index for a lookup if the leading column is not part of the search criteria.

## Edge Cases
*   **Small Tables:** In very small tables (e.g., fewer than 100 rows), the database optimizer may choose a full table scan even if an index exists, as reading the entire table into memory is faster than navigating an index structure.
*   **Soft Deletes:** When using a "deleted_at" flag instead of physical deletes, the referential integrity check at the database level may not be triggered, changing the performance profile of the foreign key.
*   **Polymorphic Associations:** In application-level frameworks where a "foreign key" might point to multiple different tables (not enforced by the DB), standard indexing strategies apply to the ID column, but referential integrity benefits are lost.

## Related Topics
*   **1. Primary Key Design:** The foundation of relational linking.
*   **5. B-Tree Indexing:** The underlying data structure used for most foreign key indexes.
*   **22. Concurrency and Locking:** How unindexed foreign keys contribute to deadlocks and wait states.
*   **Referential Integrity Constraints:** The logical rules that foreign key indexes support.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |