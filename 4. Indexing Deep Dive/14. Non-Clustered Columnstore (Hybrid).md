# 14. Non Clustered Columnstore (Hybrid)

Canonical documentation for 14. Non Clustered Columnstore (Hybrid). This document defines concepts, terminology, and standard usage.

## Purpose
The Non-Clustered Columnstore (Hybrid) model exists to bridge the gap between Online Transactional Processing (OLTP) and Online Analytical Processing (OLAP). Traditionally, these workloads required separate systems and complex Extract, Transform, Load (ETL) processes. 

The hybrid approach allows a system to maintain a primary row-based storage format for high-speed transactions while simultaneously maintaining a secondary, columnar-based index for high-performance analytical queries. This enables "Real-time Operational Analytics" by allowing complex aggregations to run directly against live operational data without necessitating a separate data warehouse.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural pattern rather than specific database engine syntax.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The dual-storage architecture (Rowstore + Columnstore).
> * Mechanisms for maintaining data consistency between formats.
> * Performance trade-offs of hybrid indexing.
> * Theoretical foundations of Hybrid Transactional/Analytical Processing (HTAP).

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., MSSQL, Oracle, or PostgreSQL extensions).
> * Hardware-specific optimizations (e.g., NVMe vs. HDD tuning).
> * Pure Columnstore-only architectures (Clustered Columnstore).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Rowstore** | A data storage format where data is stored in rows, optimized for point lookups and high-frequency inserts/updates. |
| **Columnstore** | A data storage format where data is grouped by columns rather than rows, optimized for large-scale scans and aggregations. |
| **HTAP** | Hybrid Transactional/Analytical Processing; the ability to perform both transaction processing and analytics on the same data set. |
| **Delta Store** | A temporary row-based buffer used to store incoming changes before they are compressed into the columnar format. |
| **Compression Delay** | A configurable threshold or time period before row-based data is migrated into a compressed columnar segment. |
| **Vectorized Execution** | A query processing method where operations are performed on a batch of values (vectors) rather than one row at a time. |

## Core Concepts
The fundamental idea behind a Non-Clustered Columnstore is the **Dual-Format Persistence**. The underlying table remains a standard heap or B-tree (Rowstore), ensuring that transactional integrity and single-row lookups remain performant. The Non-Clustered Columnstore is a secondary structure—essentially a "shadow" of the data—organized by columns.

### The Hybrid Mechanism
When data is modified in the primary Rowstore, the system must eventually reflect those changes in the Columnstore. This is typically handled via a "Delta Store" or "Tuple Mover" process. This ensures that analytical queries see a consistent view of the data without requiring the Columnstore to be updated synchronously for every single row insert, which would be computationally expensive.

> [!TIP]
> Think of the Rowstore as a ledger where you write every transaction line-by-line, and the Columnstore as a set of summary spreadsheets organized by category. The Hybrid model keeps both in sync so you can check a specific transaction or calculate a yearly total with equal efficiency.

## Standard Model
The standard model for a Non-Clustered Columnstore involves three main components:

1.  **Primary Rowstore Table:** The source of truth for all transactional operations.
2.  **The Columnar Index:** A compressed, read-optimized representation of selected (or all) columns from the primary table.
3.  **The Mapping/Delete Bitmap:** A mechanism to track which rows in the Columnstore are no longer valid (due to updates or deletes in the Rowstore) before the next compression cycle.

In this model, the query optimizer is responsible for "Cost-Based Selection." If a query asks for a single record by ID, the optimizer chooses the Rowstore. If a query asks for the average value of a million records, the optimizer chooses the Columnstore.

## Common Patterns
*   **Real-Time Reporting:** Running dashboards directly against the production database instead of waiting for nightly ETL jobs.
*   **Filtered Columnstore:** Creating a Columnstore index only on a subset of data (e.g., only on "Closed" orders), which reduces the overhead of maintaining the index for highly volatile "Active" data.
*   **Archival Compression:** Using the Columnstore index to provide high compression ratios for historical data that still needs to be queryable.

## Anti-Patterns
*   **Over-Indexing Volatile Columns:** Applying a Columnstore index to columns that undergo constant, high-frequency updates. This leads to "Delta Store Bloat" and high CPU overhead for index maintenance.
*   **Small Batch Inserts:** Inserting data one row at a time into a table with a Columnstore index can lead to fragmented rowgroups, significantly degrading analytical performance.
*   **Using for Point Lookups:** Attempting to use the Columnstore for queries that return a single row. The overhead of decompressing columnar segments is far higher than a simple B-tree seek.

> [!CAUTION]
> Avoid circular dependencies where analytical triggers based on the Columnstore attempt to update the Rowstore synchronously, as this can lead to severe transaction deadlocks.

## Edge Cases
*   **Schema Evolution:** Adding or dropping columns in the primary Rowstore requires the secondary Columnstore to be rebuilt or altered, which can be a resource-intensive operation on large datasets.
*   **Memory Pressure:** Columnstore structures often require significant memory for the "Compression Units." In low-memory environments, the system may revert to Rowstore scans, negating the benefits of the hybrid model.
*   **Large Object (LOB) Data:** Most hybrid models struggle with LOB data types (e.g., BLOBs, large strings). These are often stored outside the columnar structure, leading to performance "cliffs" when such columns are included in analytical queries.

## Related Topics
*   **Clustered Columnstore:** The primary storage format is columnar; there is no underlying Rowstore.
*   **ETL/ELT:** The traditional method of moving data from Rowstore to Columnstore across different physical systems.
*   **Vectorization:** The CPU-level optimization that makes Columnstore processing significantly faster than row-by-row processing.
*   **Materialized Views:** A different approach to pre-calculating aggregations, though less flexible than a Columnstore index.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |