# 7. Filtered Indexes: Use Cases and Limitations

Canonical documentation for [7. Filtered Indexes: Use Cases and Limitations](4. Indexing Deep Dive/7. Filtered Indexes: Use Cases and Limitations.md). This document defines concepts, terminology, and standard usage.

## Purpose
The purpose of filtered indexes is to optimize data retrieval and storage efficiency by indexing only a specific subset of data within a table. In large-scale data environments, indexing an entire column can lead to bloated index structures, increased maintenance overhead, and diminished performance if the majority of queries target only a small, well-defined portion of the dataset. Filtered indexes address this by applying a logical predicate to the index creation process, ensuring that only rows meeting specific criteria are included in the index tree.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural logic of partial indexing rather than specific database engine syntax.

## Scope
This documentation covers the theoretical framework, strategic application, and inherent constraints of partial or filtered indexing strategies.

> [!IMPORTANT]
> **In scope:**
> * Core functionality of predicate-based indexing.
> * Theoretical boundaries of index selectivity and storage.
> * Strategic use cases for data lifecycle management and sparse data.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., SQL Server vs. PostgreSQL syntax differences).
> * Hardware-level storage optimization.
> * Non-relational indexing structures (e.g., NoSQL document indexing).

## Definitions
| Term | Definition |
|------|------------|
| Filtered Index | A non-clustered index that includes a subset of rows based on a defined predicate. |
| Predicate | The logical expression (e.g., `WHERE status = 'Active'`) used to filter the data included in the index. |
| Selectivity | The measure of how much data is filtered; high selectivity means the index covers a very small percentage of the total rows. |
| Sparse Data | Data sets where many columns contain NULL values or default values that are rarely queried. |
| Index Maintenance | The computational cost of updating an index when the underlying table data is modified (INSERT, UPDATE, DELETE). |

## Core Concepts
Filtered indexes operate on the principle of "Partial Indexing." Unlike a standard index that maps every row in a table, a filtered index uses a filter predicate to prune the index tree at the time of creation and during subsequent updates.

**Storage Efficiency**
By excluding irrelevant data, the index consumes significantly less disk space and memory. This allows for more efficient use of the buffer pool, as more of the relevant index can reside in RAM.

**Maintenance Optimization**
Since the index only contains a subset of the table, it is only updated when the modified rows meet the filter criteria. If a row is updated but does not satisfy the predicate, the filtered index remains untouched, reducing I/O overhead.

> [!TIP]
> Think of a filtered index like a specialized directory in a library that only lists "New Releases" rather than every book in the building. It is faster to search and easier to update, provided you are only looking for new books.

## Standard Model
The standard model for a filtered index involves three primary components:
1.  **The Target Columns:** The data columns to be indexed for search performance.
2.  **The Included Columns:** Non-key columns added to the leaf level to cover specific queries.
3.  **The Filter Predicate:** A deterministic logical expression that defines the scope of the index.

For a filtered index to be effective, the query optimizer must be able to prove that the query's requirements are a subset of the index's predicate. If the query's filter is broader than the index's filter, the index cannot be used.

## Common Patterns
*   **Sparse Column Indexing:** Creating indexes on columns where the majority of values are NULL. The filter `WHERE Column IS NOT NULL` prevents the index from storing thousands of empty entries.
*   **Status-Based Indexing:** In workflow systems, queries often target "Active," "Pending," or "Error" states. A filtered index on `WHERE Status = 'In-Progress'` optimizes these frequent lookups.
*   **Data Partitioning Simulation:** Using filtered indexes to create "hot" and "cold" data zones within a single table based on timestamps (e.g., `WHERE CreatedDate > '2023-01-01'`).
*   **Unique Constraints on Subsets:** Enforcing uniqueness only for a specific condition, such as allowing only one "Primary" email address per user while allowing multiple "Secondary" addresses.

## Anti-Patterns
*   **Over-Filtering:** Creating too many highly specific filtered indexes that overlap, leading to "index sprawl" and complicating the query optimizer's plan selection.
*   **Volatile Predicates:** Using non-deterministic functions (like `GETDATE()` or `CURRENT_TIMESTAMP`) in the filter predicate. Most systems require predicates to be deterministic.
*   **Ignoring Parameter Sniffing:** Relying on filtered indexes with parameterized queries where the parameter might fall outside the filtered range, potentially causing the optimizer to ignore the index entirely.

> [!CAUTION]
> Avoid creating filtered indexes on columns that undergo frequent updates which cause rows to move in and out of the filter criteria. This can lead to heavy fragmentation and excessive transaction log activity.

## Edge Cases
*   **Collation Mismatches:** If the filter predicate involves string comparisons, the collation of the index must match the collation of the query for the optimizer to utilize the index.
*   **Implicit Conversions:** If a query uses a different data type than the filtered index predicate (e.g., comparing an integer to a string), the optimizer may fail to match the query to the index.
*   **Computed Columns:** Some implementations allow filtered indexes on computed columns, but this introduces complexities regarding when the computation is persisted and how the filter is evaluated.
*   **Include vs. Key:** Deciding whether a column belongs in the filter predicate, the index key, or as an included column requires careful analysis of the query patterns.

## Related Topics
*   **Index Covering:** The practice of including all columns required by a query within the index.
*   **Selectivity and Cardinality:** The mathematical foundations of how optimizers choose between scans and seeks.
*   **Partitioned Tables:** A physical data organization strategy that shares some goals with filtered indexing but operates at the storage level.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |