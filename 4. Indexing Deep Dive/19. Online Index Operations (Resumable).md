# 19. Online Index Operations (Resumable)

Canonical documentation for [19. Online Index Operations (Resumable)](4. Indexing Deep Dive/19. Online Index Operations (Resumable).md). This document defines concepts, terminology, and standard usage.

## Purpose
The primary purpose of Online Resumable Index Operations is to facilitate the maintenance of large-scale data structures in high-availability environments. Traditional index operations often require exclusive locks or, if performed online, are atomic "all-or-nothing" tasks. In the event of a system failure, resource exhaustion, or the end of a maintenance window, a non-resumable operation must roll back entirely, wasting significant computational and I/O resources.

Resumable operations address these challenges by allowing an index build or rebuild to be paused and resumed from the point of interruption. This ensures that progress is preserved, resource consumption can be managed across multiple windows, and system administrators can react to unforeseen environmental pressures without losing work.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
This documentation covers the theoretical framework, operational lifecycle, and architectural requirements for index operations that support both concurrent access (Online) and state persistence (Resumable).

> [!IMPORTANT]
> **In scope:**
> * Mechanics of state preservation during index DDL (Data Definition Language) operations.
> * Concurrency models allowing DML (Data Manipulation Language) during index construction.
> * Resource management strategies for long-running maintenance tasks.
> * Theoretical boundaries of "Online" availability.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific syntax or command-line arguments.
> * Performance benchmarking for specific hardware configurations.
> * Implementation details of specific B-Tree or LSM-tree algorithms.

## Definitions
| Term | Definition |
|------|------------|
| Online Operation | A process that allows concurrent Read/Write access to the underlying table while the index is being modified. |
| Resumable Operation | An operation capable of saving its execution state to persistent storage, allowing it to stop and restart without restarting from the beginning. |
| Maintenance Window | A defined period during which system resources are allocated for administrative tasks. |
| State Metadata | Data stored by the system to track the progress, scan position, and mapping of a resumable operation. |
| Log Pressure | The accumulation of transaction or redo logs generated by the ongoing index operation and concurrent DML. |
| Quiescence | The state of being temporarily inactive or paused while maintaining the integrity of the partial work. |

## Core Concepts
The fundamental idea behind Online Resumable Index Operations is the decoupling of the index lifecycle from a single, continuous transaction.

### State Persistence
Unlike standard transactions that must either commit or roll back, a resumable operation checkpoints its progress. This involves tracking the last processed data page or key range. If the operation is paused, the system retains this "high-water mark" in a system catalog.

### Concurrency and Locking
To remain "Online," the operation must utilize a multi-phase locking strategy. It typically begins with a short-duration shared lock to initialize metadata, transitions to a concurrent phase where DML is permitted, and concludes with a final short-duration lock to synchronize the last remaining changes.

### Resource Governance
Resumable operations allow for "Time-Slicing." An administrator can execute an index rebuild for a specific duration (e.g., 60 minutes), pause it to free up I/O for peak business hours, and resume it during the next available window.

> [!TIP]
> Think of a resumable index operation like a marathon runner who can pause the race, go home to sleep, and return the next day to start exactly at the mile marker where they stopped, rather than having to return to the starting line.

## Standard Model
The standard model for a resumable index operation follows a specific state machine:

1.  **Initialization:** The system validates the request, allocates initial resources, and creates a "side-car" or "shadow" structure for the new index.
2.  **Execution (Running):** The system scans the base table and populates the new index. Concurrent DML is tracked (often via a temporary log or mapping table).
3.  **Suspension (Paused):** The operation is halted either by user command or system event (e.g., out of disk space). The current scan position and the state of the temporary log are persisted.
4.  **Resumption:** The system reads the metadata, re-establishes the scan position, and continues the population process.
5.  **Finalization (Commit):** The system performs a final catch-up of concurrent changes, swaps the old index with the new one (if a rebuild), and drops the temporary structures.

## Common Patterns
*   **Windowed Maintenance:** Executing heavy index rebuilds only during low-traffic hours, pausing automatically when the window expires.
*   **Error Recovery:** Automatically pausing an operation when a "Disk Full" or "Log Full" error occurs, allowing the administrator to add capacity before resuming.
*   **Low-Priority Background Processing:** Running the operation with a low CPU/IO priority, allowing it to be paused if the system detects high latency on primary workloads.

## Anti-Patterns
*   **Indefinite Pausing:** Leaving an operation paused for days or weeks. This can lead to massive growth in temporary logs or "side-car" structures as they must track all changes made to the base table since the pause began.
*   **Concurrent Schema Changes:** Attempting to modify the table schema (e.g., dropping a column) while an index operation on that table is paused.
*   **Ignoring Log Space:** Assuming that because an operation is resumable, it does not consume transaction log space. Resumable operations often require more log management, not less.

> [!CAUTION]
> Avoid leaving resumable operations in a "Paused" state for extended periods; this can prevent the truncation of transaction logs and lead to database-wide outages due to log exhaustion.

## Edge Cases
*   **Index Definition Mismatch:** If the index definition is altered (e.g., adding an included column) while the operation is paused, the operation must usually be aborted and restarted.
*   **Memory Pressure during Finalization:** The final "catch-up" phase requires merging concurrent DML changes. If the volume of changes is massive, this phase may require more memory or time than anticipated, potentially extending the final lock duration.
*   **System Reboot:** A robust implementation must ensure that the resumable state survives a hard system crash or reboot, allowing the operation to remain in a "Paused" state upon system start.

## Related Topics
*   **12. Concurrency Control:** How the system manages simultaneous access to data.
*   **15. Transaction Log Management:** The mechanics of recording changes for durability.
*   **22. Index Maintenance Strategies:** High-level planning for database health.
*   **Storage Allocation and Fragmentation:** The physical impact of long-running index builds.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |