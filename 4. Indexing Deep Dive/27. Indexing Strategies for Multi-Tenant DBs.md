# 27. Indexing Strategies for Multi Tenant DBs

Canonical documentation for 27. Indexing Strategies for Multi Tenant DBs. This document defines concepts, terminology, and standard usage.

## Purpose
The primary purpose of multi-tenant indexing strategies is to ensure data isolation, query performance, and resource efficiency in environments where multiple distinct customers (tenants) share the same database infrastructure. In a multi-tenant system, the database must distinguish between tenant data efficiently to prevent "noisy neighbor" effects and to ensure that query latency remains predictable as the number of tenants and the volume of data grow.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural logic of indexing rather than specific database engine syntax.

## Scope
This document covers the theoretical and structural approaches to indexing data in multi-tenant architectures, specifically focusing on shared-resource models.

> [!IMPORTANT]
> **In scope:**
> * Indexing strategies for Shared Schema, Schema-per-Tenant, and Database-per-Tenant models.
> * Composite indexing logic and tenant-prefixing.
> * Performance implications of tenant data distribution.
> * Global vs. Local indexing concepts.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., specific PostgreSQL, MySQL, or DynamoDB syntax).
> * General database tuning not specific to multi-tenancy.
> * Hardware-level storage optimization.

## Definitions
| Term | Definition |
|------|------------|
| Tenant ID | A unique identifier used to partition or label data belonging to a specific customer. |
| Composite Index | An index that encompasses multiple columns, typically starting with the Tenant ID. |
| Data Skew | A condition where one tenant has significantly more data than others, leading to unbalanced index trees. |
| Filtered (Partial) Index | An index that only includes a subset of rows, often used to isolate specific tenant data or states. |
| Noisy Neighbor | A phenomenon where one tenant's heavy resource usage (often due to poor indexing) degrades performance for others. |
| Tenant Isolation | The logical or physical separation of data to ensure tenants cannot access or interfere with each other's information. |

## Core Concepts
The fundamental challenge of multi-tenant indexing is the balance between **Global Efficiency** and **Tenant Isolation**. 

In a shared-schema environment, every query typically includes a `WHERE tenant_id = ?` clause. If the indexing strategy does not account for this, the database engine may perform full table scans or inefficient index lookups, crossing tenant boundaries and violating performance isolation.

> [!TIP]
> Think of a multi-tenant index like a massive filing cabinet. Without a "Tenant ID" tab at the very front of every folder, a clerk would have to look through every single document in the cabinet just to find the files belonging to one specific company.

### Index Locality
Index locality refers to how physically close a tenant's index entries are to one another. High locality reduces disk I/O and improves cache hit rates. Strategies that group data by Tenant ID maximize locality.

### Cardinality and Selectivity
In multi-tenant systems, the `Tenant ID` usually has high cardinality (many unique values). When combined with application-specific columns (like `created_at` or `status`), the selectivity of the index increases, allowing the database to discard irrelevant data rapidly.

## Standard Model
The generally accepted standard for multi-tenant indexing in shared-resource environments is the **Tenant-First Composite Index**.

In this model, the `Tenant ID` is placed as the leading column in almost every index. This ensures that the database engine can immediately narrow the search space to a specific tenant's data subset before evaluating other criteria.

**The Standard Structure:**
`INDEX (tenant_id, application_column_1, application_column_2)`

This model supports:
1.  **Strict Isolation:** Queries are naturally restricted to the tenant's scope.
2.  **Predictable Performance:** The B-Tree traversal starts by identifying the tenant's branch.
3.  **Efficient Deletion:** When a tenant offboards, the database can more efficiently locate and remove their specific index entries.

## Common Patterns

### 1. The Leading Tenant ID Pattern
As described in the Standard Model, placing the `tenant_id` at the start of the index. This is the most robust pattern for shared-schema relational databases.

### 2. Partitioned Indexing (Local Indexes)
In systems that support physical partitioning, indexes are "localized" to a specific partition (often defined by `tenant_id`). This prevents a single index from becoming too large to fit in memory and simplifies maintenance tasks like rebuilding indexes for a single tenant.

### 3. Partial/Filtered Indexing
For tenants with unique requirements or extremely high data volumes, partial indexes can be created.
> [!TIP]
> Use partial indexes to index only "Active" records for a specific high-volume tenant, reducing the index size for all other tenants.

### 4. Shard-Key Indexing
In distributed or NoSQL environments, the `tenant_id` often serves as the shard key or partition key. The index is then built locally on each shard, ensuring that queries do not need to "scatter-gather" across the entire cluster.

## Anti-Patterns

### The "Global-Only" Index
Creating indexes on application columns (e.g., `email`, `order_id`) without including the `tenant_id`.
> [!CAUTION]
> This forces the database to search across all tenants' data to find a specific record, which can lead to data leakage if the application logic fails, and causes massive performance degradation as the total row count grows.

### Over-Indexing Small Tenants
Creating unique, specialized indexes for every small tenant in a shared schema. This leads to "index bloat," where the metadata and index overhead consume more resources than the actual data.

### UUID Fragmentation
Using randomly generated UUIDs as the leading part of a clustered index or primary key without considering insertion order. This leads to heavy fragmentation and poor write performance.

## Edge Cases

### The "Mega-Tenant" (Data Skew)
When one tenant has 100x more data than the average tenant, a standard composite index may still result in a very deep B-Tree for that specific tenant. 
*   **Solution:** Consider moving "Mega-Tenants" to a dedicated schema or physical database where indexes can be tuned specifically for their data distribution.

### Cross-Tenant Analytics
Internal administrative tools often need to query data across all tenants (e.g., "Show me all orders across the system").
*   **Challenge:** A tenant-first index is highly inefficient for cross-tenant queries.
*   **Solution:** Maintain a separate set of "Global Indexes" specifically for administrative or analytical use cases, acknowledging the storage overhead.

### Sparse Data Tenants
Tenants who use only a small fraction of the available features.
*   **Challenge:** Standard indexes still reserve space and require maintenance for these tenants.
*   **Solution:** Use sparse indexing features if supported by the database engine.

## Related Topics
*   **Database Sharding:** The physical distribution of data across multiple nodes.
*   **Data Isolation Levels:** The logical enforcement of tenant boundaries.
*   **Query Optimization:** The process of analyzing execution plans to ensure index usage.
*   **Multi-tenant Architecture Patterns:** Shared Schema vs. Isolated Schema.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |