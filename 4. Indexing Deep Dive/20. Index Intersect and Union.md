# 20. Index Intersect and Union

Canonical documentation for [20. Index Intersect and Union](4. Indexing Deep Dive/20. Index Intersect and Union.md). This document defines concepts, terminology, and standard usage.

## Purpose
Index Intersect and Union operations address the challenge of optimizing queries that filter data across multiple independent columns. In traditional indexing strategies, a query optimizer typically selects a single index to locate records. However, when a query contains multiple predicates (using `AND` or `OR` logic), a single index may not be sufficiently selective.

These operations allow a database engine to leverage multiple secondary indexes simultaneously, combining their results in memory before accessing the underlying data storage. This reduces the need for expensive full-table scans or the creation of an exhaustive number of composite indexes for every possible column combination.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the relational algebra and data structures that govern these operations.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Logical set operations (Intersection and Union) on index entries.
> * The role of Row Identifiers (RIDs) or Primary Keys (PKs) in set operations.
> * Performance trade-offs between multi-index access and composite indexing.

> [!WARNING]
> **Out of scope:**
> * Specific vendor-specific syntax (e.g., MySQL's `index_merge` or PostgreSQL's `BitmapAnd`).
> * Hardware-level caching mechanisms.
> * Non-relational indexing structures (e.g., spatial or full-text) unless used in a hybrid context.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Index Intersection | A set operation where the engine identifies the common Row Identifiers (RIDs) present in two or more index scans (Logical `AND`). |
| Index Union | A set operation where the engine identifies the unique total of Row Identifiers (RIDs) present across multiple index scans (Logical `OR`). |
| Row Identifier (RID) | A unique internal pointer or primary key value used to locate the actual data row in the primary storage. |
| Selectivity | The ratio of rows filtered by a predicate relative to the total number of rows; high selectivity means fewer rows are returned. |
| Bitmap | A data structure often used to represent the presence or absence of rows in a set, facilitating fast bitwise operations. |

## Core Concepts
The fundamental principle of Index Intersect and Union is that indexes are essentially sets of pointers. By treating these pointers as mathematical sets, the database can perform set theory operations to narrow down the search space.

### The Set Operation Workflow
1.  **Parallel/Sequential Scans:** The engine scans multiple independent indexes based on the query predicates.
2.  **Pointer Extraction:** The engine extracts the RIDs or Primary Keys from each index.
3.  **Sorting/Hashing:** To perform an intersection or union efficiently, the pointers are typically sorted or placed into a hash table/bitmap.
4.  **Logical Combination:**
    *   **Intersection:** Only pointers appearing in *all* scanned sets are kept.
    *   **Union:** All pointers from *all* scanned sets are kept, with duplicates removed.
5.  **Data Fetch (The "Bookmark Lookup"):** The engine uses the resulting set of pointers to fetch the actual rows from the table.

> [!TIP]
> Think of Index Intersect like a Venn diagram. If you are looking for "Red" (Index A) AND "Cars" (Index B), the intersection is the overlapping middle section. If you are looking for "Red" OR "Cars," the union is the entire area covered by both circles.

## Standard Model
The standard model for these operations relies on the cost-based optimizer (CBO). The engine evaluates whether the overhead of scanning multiple indexes and performing set logic is lower than the cost of a single index scan followed by manual filtering, or a full table scan.

### Index Intersection Model
Used for `SELECT * FROM table WHERE col_a = x AND col_b = y`.
*   The engine scans the index for `col_a` and the index for `col_b`.
*   It intersects the resulting RIDs.
*   This is most effective when both columns have moderate selectivity but their combination is highly selective.

### Index Union Model
Used for `SELECT * FROM table WHERE col_a = x OR col_b = y`.
*   The engine scans the index for `col_a` and the index for `col_b`.
*   It merges the RIDs, ensuring no row is fetched twice.
*   This is often the only way to use indexes for `OR` conditions without resorting to a table scan.

## Common Patterns
*   **Faceted Search:** In e-commerce or catalogs where users can filter by multiple independent attributes (e.g., Color, Size, Brand), index intersection allows the system to handle arbitrary combinations of filters without a composite index for every permutation.
*   **Sparse Data Filtering:** When queries target multiple columns that are mostly null or contain very specific values, combining small index slices is highly efficient.
*   **OR-Condition Optimization:** Using Index Union to satisfy queries that would otherwise default to a sequential scan because a single index cannot satisfy an `OR` requirement.

## Anti-Patterns
*   **Over-Indexing:** Creating many single-column indexes specifically to rely on Intersect/Union instead of creating a well-planned composite index. Composite indexes are generally faster for known query patterns.
*   **Low-Selectivity Intersection:** Intersecting two indexes that both return 50% of the table. The overhead of the set operation and the subsequent random I/O for the data fetch will likely exceed the cost of a simple table scan.

> [!CAUTION]
> Avoid relying on Index Intersect for high-concurrency, high-throughput "point lookups." The CPU overhead of merging large RID sets can become a bottleneck compared to the direct path of a composite index.

## Edge Cases
*   **Index Sort Order:** If the indexes are already sorted by the RID, the intersection can be performed using a "Merge Join" style algorithm, which is extremely fast. If they are not sorted, the engine must spend resources sorting them or building bitmaps.
*   **Covering Indexes:** If the indexes involved in the intersect/union contain all the columns requested in the `SELECT` clause, the engine can skip the "Data Fetch" step entirely, significantly boosting performance.
*   **Highly Correlated Data:** If `col_a` and `col_b` are highly correlated (e.g., `City` and `Zip Code`), intersecting their indexes provides almost no benefit over scanning just one, as the resulting sets will be nearly identical.

## Related Topics
*   **Composite Indexes:** The primary alternative to Index Intersect/Union.
*   **Bitmap Indexing:** A specialized indexing type designed specifically for high-speed set operations.
*   **Access Paths:** The broader category of methods a database uses to retrieve data.
*   **Selectivity and Cardinality:** The statistical foundations used by the optimizer to decide whether to use Intersect or Union.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |