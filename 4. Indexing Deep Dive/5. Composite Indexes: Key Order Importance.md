# 5. Composite Indexes: Key Order Importance

Canonical documentation for [5. Composite Indexes: Key Order Importance](4. Indexing Deep Dive/5. Composite Indexes: Key Order Importance.md). This document defines concepts, terminology, and standard usage.

## Purpose
The purpose of a composite index (also known as a concatenated or multi-column index) is to optimize queries that filter or sort by multiple columns simultaneously. Unlike single-column indexes, the effectiveness of a composite index is strictly dependent on the sequence in which columns are defined. This documentation addresses the structural logic of index traversal and the performance implications of column positioning.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the underlying B-Tree structures common to most relational database systems.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The "Left-to-Right" rule (Prefix Property).
> * Impact of column order on query matching.
> * Relationship between selectivity and index positioning.
> * Interaction between equality and range predicates.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., MySQL-specific "Index Merge" or PostgreSQL "BRIN" indexes).
> * Non-ordered index structures (e.g., Hash indexes, GIN indexes).
> * Physical storage parameters (e.g., fill factor, page size).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Composite Index | A single index structure containing two or more columns as keys. |
| Leading Column | The first column defined in the index sequence; the primary sort key. |
| Index Prefix | Any subset of the index columns that starts from the first column and proceeds in order (e.g., for `(A, B, C)`, prefixes are `(A)` and `(A, B)`). |
| Selectivity | The measure of how much a column's values narrow down the result set (Unique Values / Total Rows). |
| Lexicographical Order | The method of sorting where items are ordered by the first component, then the second, and so on (similar to a dictionary). |
| Range Predicate | A query filter using operators such as `>`, `<`, `>=`, `<=`, or `BETWEEN`. |

## Core Concepts
The fundamental principle of a composite index is that the data is stored in a single, sorted structure based on the columns in the order they are defined.

**The Phone Book Analogy**
> [!TIP]
> Think of a composite index as a traditional phone book sorted by `(Last_Name, First_Name)`. You can efficiently find everyone named "Smith" (the leading column). You can also find "Smith, John" (the full prefix). However, you cannot efficiently find everyone named "John" without knowing their last name, because "John" is scattered throughout the entire book.

### The Left-to-Right Rule
An index can be used by the query optimizer only if the query's filters match the index columns starting from the left. If a query filters on the second column of an index but not the first, the index is generally bypassed (unless an index-only scan or skip-scan is performed).

### Selectivity and Filtering
The order of columns determines how quickly the search space is pruned. Placing highly selective columns (those that eliminate the most rows) at the beginning of the index is a common heuristic for optimizing point lookups.

## Standard Model
The standard model for composite index ordering follows the **Equality-Range Rule**:

1.  **Equality Predicates First:** Columns used with `=` or `IN` operators should be placed at the beginning of the index.
2.  **Range Predicates Last:** The index traversal remains highly efficient until it hits a range predicate. Once a range predicate is applied to a column in the index, any subsequent columns in that index cannot be used for efficient filtering, though they may still be used for "covering" the query.

**Example:**
For an index on `(Status, Created_At, User_ID)`:
*   A query for `WHERE Status = 'Active' AND Created_At > '2023-01-01'` uses the first two columns of the index.
*   The `User_ID` column in this specific query cannot be used to narrow the search further because it follows a range predicate (`Created_At > ...`).

## Common Patterns
*   **Point Lookup Optimization:** Ordering columns from most selective to least selective when all columns are used with equality operators.
*   **Sort Optimization:** Including columns used in `ORDER BY` clauses in the index to avoid expensive "filesort" operations. The sort columns must follow the equality filter columns in the index definition.
*   **Covering Indexes:** Including "extra" columns in the index that are not used for filtering but are requested in the `SELECT` clause, allowing the database to return data without reading the actual table rows.

## Anti-Patterns
*   **Skipping the Leading Column:** Creating a composite index on `(A, B)` and then writing queries that only filter on `B`.
*   **Redundant Indexes:** Maintaining an index on `(A)` when an index on `(A, B)` already exists. The latter can satisfy any query the former could.
*   **Range-Equality Order:** Placing a range-filtered column before an equality-filtered column (e.g., `(Date, ID)` where `Date` is searched as a range). This prevents the index from using the `ID` part of the index effectively.

> [!CAUTION]
> Avoid creating indexes with too many columns. While they may "cover" specific queries, they increase the cost of every `INSERT`, `UPDATE`, and `DELETE` operation and consume significant disk space.

## Edge Cases
*   **Index Skip Scans:** Some modern optimizers can "skip" the leading column if it has very few unique values (low cardinality), effectively treating the index as multiple sub-indexes. However, this is less efficient than a direct match.
*   **Low Cardinality Leading Columns:** While high selectivity is usually preferred first, placing a low-cardinality column (like `Gender` or `Is_Active`) first can sometimes be beneficial if almost every query filters on that column.
*   **In-List Iteration:** Using an `IN` clause (e.g., `WHERE Category IN (1, 2, 3)`) is often treated as multiple equality matches rather than a range, potentially allowing the optimizer to use subsequent columns in the index.

## Related Topics
*   **B-Tree Data Structures:** The underlying tree logic that dictates search behavior.
*   **Query Execution Plans:** How to verify if a specific index order is being utilized.
*   **Selectivity and Cardinality:** Deep dive into the statistics that guide index column ordering.
*   **Covering Indexes:** The practice of including non-filter columns for performance.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |