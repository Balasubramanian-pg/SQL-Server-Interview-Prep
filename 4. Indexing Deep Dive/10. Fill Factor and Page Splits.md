# 10. Fill Factor and Page Splits

Canonical documentation for [10. Fill Factor and Page Splits](4. Indexing Deep Dive/10. Fill Factor and Page Splits.md). This document defines concepts, terminology, and standard usage.

## Purpose
The purpose of Fill Factor and Page Split management is to optimize the balance between data storage density and the performance overhead of data modification. In systems utilizing page-based storage architectures (such as B-Tree indexes), data is organized into fixed-size blocks. As data is inserted or updated, these blocks can become full. This documentation addresses the mechanisms used to reserve space for future growth and the consequences of failing to maintain adequate space.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the underlying mechanics of page-based storage systems.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Mechanics of page-level data allocation.
> * The relationship between storage density and I/O performance.
> * Logical and physical fragmentation resulting from data movement.
> * Configuration strategies for read-heavy vs. write-heavy workloads.

> [!WARNING]
> **Out of scope:**
> * Specific vendor syntax for setting fill factors.
> * Hardware-level disk sector management.
> * Non-paged storage models (e.g., pure Log-Structured Merge-trees, though some concepts may overlap).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Page | The smallest unit of I/O used by a storage engine to manage data on disk and in memory. |
| Fill Factor | A configuration setting that determines the percentage of space on each page to be filled with data during index creation or rebuilding. |
| Page Split | The process of dividing the contents of a full page into two pages to accommodate new data that cannot fit in the existing structure. |
| Fragmentation | The condition where data pages are not physically contiguous or contain excessive empty space, leading to inefficient I/O. |
| Leaf Level | The bottom-most level of an index structure where the actual data or pointers to data rows reside. |

## Core Concepts
The fundamental principle of page management is the trade-off between **Read Efficiency** and **Write Flexibility**.

**The Page Structure**
Data is stored in pages of a fixed size (typically 8KB, 16KB, or 64KB). When a page is full and a new row must be inserted into that specific logical position (based on the index key), the system must make room.

**The Mechanics of a Page Split**
When a split occurs:
1. A new page is allocated.
2. Approximately half of the data from the original page is moved to the new page.
3. The index pointers are updated to reflect the new structure.
4. The new row is inserted into the appropriate page.

> [!TIP]
> Think of a page split like a bookshelf. If a shelf is packed tightly with books in alphabetical order and you need to insert a new book in the middle, you cannot simply squeeze it in. You must take half the books off that shelf and move them to a new shelf to create the necessary gap.

## Standard Model
The standard model for managing page density involves setting a Fill Factor percentage.

1.  **High Fill Factor (90-100%):** Maximizes data density. More rows fit on a single page, reducing the number of pages that must be read into memory. This is ideal for static or read-only data.
2.  **Lower Fill Factor (70-80%):** Leaves "padding" on each page. This allows for inserts and updates (that increase row size) to occur without triggering immediate page splits.
3.  **The Split Penalty:** Page splits are resource-intensive. They require additional I/O, logging of the structural change, and can cause physical fragmentation where logically sequential pages are scattered across the storage medium.

## Common Patterns
*   **Read-Heavy Workloads:** Use a Fill Factor of 100 or 0 (implementation-specific defaults for "full"). This ensures the smallest possible storage footprint and maximum cache efficiency.
*   **Write-Heavy Workloads:** Use a Fill Factor between 70% and 90%. This anticipates growth and minimizes the frequency of expensive page splits.
*   **Random Key Insertion:** Tables using non-sequential keys (like random UUIDs) are highly susceptible to page splits because data is inserted into random pages rather than at the end of the index. These require lower Fill Factors.
*   **Sequential Key Insertion:** Tables using identity or auto-incrementing keys typically insert data at the "end" of the index. These can often maintain a high Fill Factor because splits only occur at the final page, which is a less expensive operation.

## Anti-Patterns
*   **Global Low Fill Factor:** Setting a low Fill Factor (e.g., 50%) across an entire system. This doubles the storage requirements and reduces cache hits, as half of every page in memory is empty space.
*   **Ignoring Fragmentation:** Failing to monitor fragmentation levels. Over time, even a well-configured Fill Factor will degrade as pages fill up, eventually requiring an index rebuild to restore the padding.
*   **Static Fill Factor on Volatile Data:** Applying a 100% Fill Factor to a table that experiences frequent updates to variable-length columns, leading to constant "mid-page" splits.

> [!CAUTION]
> Setting an excessively low Fill Factor can lead to "Index Bloat," where the index becomes so large that it no longer fits in memory, causing a massive degradation in read performance that outweighs any write performance gains.

## Edge Cases
*   **Variable-Length Columns:** If a row is updated and a `VARCHAR` or `BLOB` column grows in size, it may trigger a page split even if no new rows are inserted.
*   **Bulk Loading:** During initial data migration, it is often more efficient to use a 100% Fill Factor for speed, then rebuild the index with a lower Fill Factor once the system enters a transactional state.
*   **Small Tables:** For tables that fit entirely within a few pages, Fill Factor is largely irrelevant as the overhead of a split is negligible compared to the total system throughput.

## Related Topics
*   **B-Tree Index Structures:** The primary data structure affected by page splits.
*   **Index Fragmentation and Reorganization:** The process of correcting the effects of page splits.
*   **I/O Subsystem Performance:** How physical disk layout interacts with logical page fragmentation.
*   **Transaction Logging:** The impact of page splits on the volume of write-ahead logs.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |