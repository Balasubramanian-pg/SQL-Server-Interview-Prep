# 18. The 'Tipping Point' in Index Usage

Canonical documentation for [18. The 'Tipping Point' in Index Usage](4. Indexing Deep Dive/18. The 'Tipping Point' in Index Usage.md). This document defines concepts, terminology, and standard usage.

## Purpose
The "Tipping Point" describes the specific threshold at which a database query optimizer determines that performing a full table scan (sequential access) is more efficient than utilizing a non-clustered index (random access via lookups). This topic addresses the fundamental trade-off between the overhead of navigating index structures and the raw throughput of reading data pages sequentially.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the cost-based optimization logic common to most relational database management systems (RDBMS).

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The mathematical and logical basis for the crossover between index seeks and table scans.
> * The impact of data distribution and selectivity on optimizer decisions.
> * The relationship between page density and I/O costs.

> [!WARNING]
> **Out of scope:**
> * Specific syntax for vendor-specific query hints (e.g., `FORCESEEK`).
> * Proprietary internal cost constants used by specific database engines.
> * Hardware-level disk controller optimization.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Selectivity | The measure of how many rows are returned by a filter relative to the total number of rows (Total Rows / Distinct Values). |
| Bookmark Lookup | The process of using a pointer found in a non-clustered index to retrieve the full data row from the heap or clustered index. |
| Sequential I/O | Reading data blocks in the order they are physically stored on the storage medium. |
| Random I/O | Accessing data blocks in a non-contiguous order, often requiring multiple "jumps" across the storage medium. |
| Page Density | The number of data rows that fit into a single atomic unit of storage (a page or block). |

## Core Concepts
The Tipping Point is driven by the cost of "Bookmark Lookups." When a query uses a non-clustered index to find rows, the index provides a pointer to the actual data. If the query requires columns not present in the index, the engine must perform a lookup for every matching row.

> [!TIP]
> Think of a library book. If you need to find three specific quotes, using the index at the back of the book is efficient. However, if you need to find 300 quotes scattered across 400 pages, it is faster to simply read the book from start to finish than to constantly flip back and forth between the index and the pages.

The Tipping Point typically occurs when the number of rows requested exceeds a small percentage of the total pages in the table—not necessarily a percentage of the total rows.

## Standard Model
The generally accepted model for the Tipping Point is based on the cost of I/O. 

1.  **Index Access Cost:** (Cost of reading index pages) + (Number of matching rows × Cost of a single random I/O lookup).
2.  **Table Scan Cost:** (Total number of data pages × Cost of a single sequential I/O).

The "Tipping Point" is the intersection where:
`Index Access Cost > Table Scan Cost`

In most modern systems, this point is reached when a query retrieves between **3% and 30%** of the total rows, depending heavily on row size and how many rows fit on a single page. If a table has very wide rows (low page density), the tipping point occurs much earlier.

## Common Patterns
*   **Narrow Filters:** Queries with high selectivity (returning very few rows) consistently use index seeks.
*   **Wide Filters:** Queries with low selectivity (returning a large portion of the table) trigger the tipping point and result in full scans.
*   **Covering Indexes:** If an index contains all the columns requested by a query (a "Covering Index"), the Tipping Point is effectively eliminated because no bookmark lookups are required. The engine can perform a sequential scan of the index itself, which is almost always smaller than the table.

## Anti-Patterns
*   **Forcing Index Usage:** Manually forcing an index via hints when the query is past the tipping point. This often results in significantly worse performance due to excessive random I/O.
*   **Over-Indexing:** Creating indexes on columns with very low cardinality (e.g., a "Boolean" flag). The optimizer will rarely use these indexes because the tipping point is reached almost immediately.

> [!CAUTION]
> Avoid assuming that the presence of an index guarantees its use. Relying on "Index Seeks" as a universal performance metric without considering selectivity can lead to inefficient execution plans.

## Edge Cases
*   **SSD vs. HDD:** On Solid State Drives, the cost of random I/O is significantly lower than on traditional spinning disks. This shifts the Tipping Point, allowing the optimizer to favor index lookups for a larger percentage of rows.
*   **Data Correlation:** If the data is physically sorted (clustered) in the same order as the non-clustered index, the "random" I/O becomes semi-sequential, potentially pushing the tipping point much higher.
*   **Stale Statistics:** If the database's internal statistics are outdated, the optimizer may incorrectly estimate the number of rows (selectivity) and fail to recognize that the tipping point has been crossed, leading to a sub-optimal plan.

## Related Topics
*   **Selectivity and Cardinality:** The mathematical foundation for how many rows are expected.
*   **Covering Indexes:** The primary method for bypassing tipping point limitations.
*   **Statistics and Histograms:** How the engine calculates where the query falls relative to the tipping point.
*   **Access Methods:** The difference between Seeks, Scans, and Lookups.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |