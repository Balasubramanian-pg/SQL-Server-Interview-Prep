# 8. Index Fragmentation: Internal vs External

Canonical documentation for [8. Index Fragmentation: Internal vs External](4. Indexing Deep Dive/8. Index Fragmentation: Internal vs External.md). This document defines concepts, terminology, and standard usage.

## Purpose
Index fragmentation addresses the degradation of data storage efficiency and access performance within indexed data structures. As data is inserted, updated, or deleted, the physical and logical organization of the index can deviate from its optimal state. This topic exists to define the two primary modes of this degradation—Internal and External—and to provide a framework for understanding how they impact system I/O, memory utilization, and query execution speed.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the structural mechanics of B-tree and similar indexed storage systems.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Logical vs. physical ordering of data pages.
> * Space utilization within individual storage units (pages/blocks).
> * The mechanics of page splitting and its contribution to fragmentation.
> * Impact of fragmentation on scan vs. seek operations.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., SQL Server `REORGANIZE` vs. Oracle `COALESCE`).
> * Operating system-level file system fragmentation.
> * Hardware-specific storage optimizations (e.g., SSD wear leveling).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Page (or Block) | The smallest unit of I/O used by the database engine to manage data. |
| Internal Fragmentation | The existence of unused or "empty" space within a single data page. |
| External Fragmentation | A condition where the logical order of pages in an index does not match their physical order on the storage medium. |
| Page Split | The process of moving half the data from a full page to a new page to accommodate an insertion. |
| Fill Factor | A configuration setting that determines the percentage of space to be filled on each page during index creation or rebuild. |
| Logical Order | The sequence of data as defined by the index key. |
| Physical Order | The actual sequence of pages as they are stored on the disk or persistent storage. |

## Core Concepts
The fundamental idea behind index fragmentation is the trade-off between write flexibility and read efficiency.

**Internal Fragmentation (Density)**
Internal fragmentation occurs when pages have a low "density." If a page can hold 100 rows but only contains 60, the page is 40% fragmented. This leads to "bloat," where the database must read more pages into memory (Buffer Cache) than necessary to retrieve the same amount of data.

**External Fragmentation (Order)**
External fragmentation occurs when the "next page" pointer in a logical sequence points to a page that is physically distant from the current page. This forces the storage subsystem to perform non-sequential I/O, which is historically expensive for mechanical disks and still impacts metadata overhead in modern storage.

> [!TIP]
> Think of a multi-volume encyclopedia. 
> **Internal Fragmentation** is like having only two entries on a page meant for twenty; you have to flip through more pages to read the same amount of information. 
> **External Fragmentation** is like finding Volume 5 on a completely different shelf than Volume 4; you have to physically move to a different location to continue reading in order.

## Standard Model
The standard model for index fragmentation follows a predictable lifecycle:

1.  **Initialization:** An index is created or rebuilt. Pages are filled according to the **Fill Factor**, and logical order matches physical order.
2.  **Data Modification:** 
    *   **Inserts:** If a new row belongs on a full page, a **Page Split** occurs. The engine allocates a new page (often at the end of the file) and moves half the data there.
    *   **Updates:** If an update increases the size of a row beyond the remaining space on a page, it may trigger a split.
    *   **Deletes:** Removing rows leaves gaps within pages, increasing internal fragmentation.
3.  **Degradation:** Over time, the index becomes "sparse" (Internal) and "scattered" (External).
4.  **Maintenance:** The index is either **Reorganized** (compacting pages and reordering them in place) or **Rebuilt** (dropping and recreating the index from scratch).

## Common Patterns
*   **Ordered Insert Pattern:** Using a monotonically increasing key (like an Identity or Sequence) minimizes page splits and external fragmentation because new data is always appended to the end of the index.
*   **Random Insert Pattern:** Using GUIDs or UUIDs as keys causes frequent page splits across the entire index structure, leading to rapid fragmentation.
*   **Read-Heavy Optimization:** For static or read-heavy data, a high Fill Factor (e.g., 90-100%) is used to maximize internal density.
*   **Write-Heavy Optimization:** For volatile data, a lower Fill Factor (e.g., 70-80%) is used to provide "padding" on pages, delaying the need for page splits.

## Anti-Patterns
*   **Over-Maintenance:** Rebuilding indexes daily regardless of actual fragmentation levels. This consumes excessive CPU, I/O, and transaction log space for diminishing returns.
*   **Ignoring Small Tables:** Attempting to fix fragmentation on tables that occupy only a few pages. Fragmentation is irrelevant if the entire index fits into a single extent or a few memory blocks.
*   **100% Fill Factor on Random Keys:** Setting a 100% fill factor on an index with random insertion patterns, which guarantees a page split for nearly every insert.

> [!CAUTION]
> Frequent index rebuilding on large tables can cause transaction log exhaustion and block concurrent user activity in systems without "Online" rebuild capabilities.

## Edge Cases
*   **LOB Data:** Large Object (LOB) data (e.g., BLOBs, CLOBs) is often stored in separate structures. Fragmentation in the primary index may not reflect fragmentation in the LOB storage.
*   **Append-Only Tables with Deletes:** Tables where data is only added to the end but deleted from the beginning (like a sliding window log) can show high internal fragmentation that does not necessarily impact insert performance but severely impacts range scans.
*   **Compressed Indexes:** When compression is used, internal fragmentation becomes harder to calculate because the number of rows per page varies based on the data's compressibility rather than just the row size.

## Related Topics
*   **B-Tree Structures:** The underlying architecture most susceptible to these fragmentation types.
*   **Fill Factor Management:** The primary preventative measure for internal fragmentation.
*   **Statistics:** Fragmentation can lead to stale statistics, causing the query optimizer to choose sub-optimal execution plans.
*   **I/O Subsystems:** The physical layer that determines the actual performance penalty of external fragmentation.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |