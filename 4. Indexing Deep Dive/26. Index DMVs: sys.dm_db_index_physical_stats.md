# 26. Index DMVs: sys.dm_db_index_physical_stats

Canonical documentation for [26. Index DMVs: sys.dm_db_index_physical_stats](4. Indexing Deep Dive/26. Index DMVs: sys.dm_db_index_physical_stats.md). This document defines concepts, terminology, and standard usage.

## Purpose
The primary purpose of `sys.dm_db_index_physical_stats` is to provide visibility into the physical health and storage characteristics of database indexes and heaps. It addresses the need for database administrators and developers to quantify fragmentation, measure storage efficiency (page density), and determine the physical size of data structures. By exposing the underlying physical layout of B-trees and heaps, this function enables informed decisions regarding index maintenance, such as reorganization or rebuilding.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative regarding the physical storage concepts represented by this dynamic management function.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Analysis of logical and physical fragmentation within B-trees and heaps.
> * Evaluation of page density and storage utilization.
> * Understanding the impact of scanning modes (LIMITED, SAMPLED, DETAILED) on resource consumption and accuracy.
> * Interpretation of output columns related to record counts and page counts.

> [!WARNING]
> **Out of scope:**
> * Specific T-SQL syntax for `ALTER INDEX` operations.
> * Performance tuning of query execution plans (logical optimization).
> * In-memory OLTP (Memory-Optimized) structures, which do not use this DMV in the same physical context.

## Definitions
| Term | Definition |
|------|------------|
| External Fragmentation | Occurs when the logical order of pages in an index (based on the key) does not match the physical order within the data files. |
| Internal Fragmentation | Occurs when pages have a large amount of empty space, leading to lower page density and increased I/O requirements. |
| B-tree | A tree data structure that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time. |
| Heap | A table without a clustered index; data is stored in no particular order. |
| Page | The fundamental unit of data storage, typically 8 KB in size. |
| Extent | A collection of eight physically contiguous pages, used to manage space allocation. |
| Fill Factor | A setting that determines the percentage of space on each leaf-level page to be filled with data during index creation or rebuilds. |

## Core Concepts
The physical health of an index is defined by how efficiently it utilizes storage and how sequentially its pages are arranged.

**Fragmentation Types**
1. **Logical Fragmentation:** This is the percentage of out-of-order pages in the leaf level of an index. High logical fragmentation increases the cost of ordered scans because the storage engine must perform more random I/O.
2. **Extent Fragmentation:** This occurs when the extents of an index are not physically contiguous. This is particularly relevant for large scans.

**Page Density**
Page density (represented as `avg_page_space_used_in_percent`) indicates how "full" the data pages are. Low density (high internal fragmentation) means the database must read more pages to retrieve the same amount of data, wasting memory in the buffer pool and increasing I/O overhead.

> [!TIP]
> Think of an index like a physical book. External fragmentation is like having the pages of the book bound in the wrong order (Page 1, then Page 50, then Page 2). Internal fragmentation is like having only one sentence printed on every page, making the book much thicker and harder to carry than necessary.

## Standard Model
The standard model for using `sys.dm_db_index_physical_stats` involves passing specific parameters to control the depth and scope of the analysis:

1. **Database ID:** The unique identifier of the database.
2. **Object ID:** The identifier for the table or view.
3. **Index ID:** The identifier for the specific index (0 for heaps, 1 for clustered indexes, >1 for non-clustered).
4. **Partition Number:** The specific partition to analyze.
5. **Mode:** The scanning algorithm used to gather statistics.

**Scanning Modes:**
* **LIMITED:** The fastest mode. It scans the smallest number of pages. For indexes, it only scans the parent-level pages of the leaf level. For heaps, it examines the associated PFS and IAM pages.
* **SAMPLED:** Performs a 1% sample of all pages in the index or heap. If the index has fewer than 10,000 pages, it defaults to DETAILED.
* **DETAILED:** Scans all pages and counts all rows. This provides the most accurate statistics but incurs the highest resource cost.

## Common Patterns
The most frequent application of this function is to automate index maintenance. The generally accepted thresholds for maintenance actions are:

* **Fragmentation < 5%:** No action required.
* **Fragmentation 5% to 30%:** Perform `ALTER INDEX REORGANIZE`. This is an online operation that defragments the leaf level by physically reordering pages and compacting them.
* **Fragmentation > 30%:** Perform `ALTER INDEX REBUILD`. This is a more intensive operation that creates a fresh copy of the index, removing both internal and external fragmentation.

## Anti-Patterns
* **Running DETAILED mode in Production:** Executing the function in `DETAILED` mode on large tables during peak hours can cause significant I/O pressure and may block other administrative tasks.
* **Ignoring Heaps:** Neglecting to monitor fragmentation in heaps (Index ID 0). While heaps don't have logical order, they can suffer from severe internal fragmentation and "forwarded records," which degrade performance.
* **Over-Maintenance:** Rebuilding indexes daily regardless of fragmentation levels. This creates unnecessary transaction log growth and consumes CPU/IO resources without providing a performance benefit.

> [!CAUTION]
> Avoid using this DMV in a tight loop across all databases and tables without implementing a timeout or resource governor, as it is a metadata-heavy and I/O-intensive operation.

## Edge Cases
* **Small Tables:** Indexes on tables with fewer than 8 pages (one extent) often show high fragmentation that cannot be removed. This is because the pages are stored on mixed extents shared by other objects. This fragmentation is usually harmless.
* **LOB Data:** Large Object (LOB) data (e.g., `VARCHAR(MAX)`, `BLOB`) is stored in separate structures. The DMV provides statistics for these (`LOB_DATA` and `ROW_OVERFLOW_DATA` allocation units), which may require different maintenance strategies than standard B-tree data.
* **Columnstore Indexes:** While the DMV can be called for Columnstore indexes, the interpretation of "fragmentation" differs significantly, focusing more on deleted rows within rowgroups rather than B-tree page order.

## Related Topics
* **Index Maintenance:** The operational application of the data provided by this DMV.
* **Buffer Pool Management:** How page density affects memory efficiency.
* **I/O Subsystems:** The relationship between physical page order and storage hardware performance (Sequential vs. Random I/O).
* **sys.dm_db_index_usage_stats:** A complementary DMV that tracks how often indexes are used, rather than their physical state.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |