# 22. XML Indexes: Primary vs Secondary

Canonical documentation for [22. XML Indexes: Primary vs Secondary](4. Indexing Deep Dive/22. XML Indexes: Primary vs Secondary.md). This document defines concepts, terminology, and standard usage.

## Purpose
The purpose of XML indexing is to optimize the retrieval and manipulation of semi-structured data stored within a relational or document-oriented database. Because XML data is typically stored as large character or binary objects (BLOBs), standard database indexes are ineffective at querying internal elements, attributes, or hierarchical relationships. 

XML indexes address the performance bottleneck of "on-the-fly" parsing by creating a persistent, shredded representation of the XML structure. This allows the query engine to navigate the XML hierarchy and filter by values without re-parsing the entire document at runtime.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural relationship between primary and secondary indexing structures.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The structural relationship between primary and secondary XML indexes.
> * The mechanism of XML "shredding" for indexing purposes.
> * Functional categories of secondary indexes (Path, Value, Property).
> * Performance trade-offs between index types.

> [!WARNING]
> **Out of scope:**
> * Specific vendor syntax (e.g., T-SQL, PL/SQL, XQuery implementation details).
> * Non-XML semi-structured formats (e.g., JSON, YAML) unless used for comparison.
> * Full-text search indexing (which operates on tokens rather than structural nodes).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Primary XML Index | A persisted, shredded representation of an XML column that maps every node, path, and value to a searchable internal table. |
| Secondary XML Index | A specialized index built upon an existing Primary XML Index to optimize specific query patterns (e.g., path-based or value-based lookups). |
| Shredding | The process of decomposing an XML document into a relational-style internal structure consisting of rows and columns representing nodes. |
| Node ID | A unique identifier assigned to each element or attribute within the XML hierarchy to maintain structural order. |
| Path | The hierarchical route from the root element to a specific node. |

## Core Concepts
The fundamental concept of XML indexing is the transition from a "Blob-based" storage model to a "Node-based" storage model.

### The Dependency Chain
A Secondary XML Index cannot exist without a Primary XML Index. The Primary Index acts as the "Source of Truth" for the shredded data, while Secondary Indexes act as specialized views or pointers into that shredded data to accelerate specific access paths.

### Shredding and Persistence
When a Primary XML Index is created, the system parses all XML instances in the column and populates an internal "work table." This table typically stores:
* The Tag Name (Element/Attribute name).
* The Node Value.
* The Node Type (Element, Attribute, Text).
* The Path Information (to preserve hierarchy).
* A reference back to the original base table row.

> [!TIP]
> Think of the Primary XML Index as a "Map" of a building, and Secondary XML Indexes as "Specialized Directories" (e.g., an alphabetical list of residents or a list of room numbers) that help you find specific locations on that map faster.

## Standard Model
The standard model for XML indexing follows a two-tier architecture:

1.  **Primary XML Index (The Foundation):**
    *   Indexes all nodes (elements, attributes, namespaces).
    *   Enables the use of XQuery/XPath in filters.
    *   Reduces the cost of parsing but may increase storage requirements significantly (often 2x-5x the size of the original data).

2.  **Secondary XML Indexes (The Optimizers):**
    *   **Path-based:** Optimized for queries that specify a known path (e.g., `/Root/Customer/OrderID`). It speeds up structural navigation.
    *   **Value-based:** Optimized for queries where the path is unknown or contains wildcards, but the value is known (e.g., `//ID[.="123"]`).
    *   **Property-based:** Optimized for retrieving multiple values from a single XML instance when the path is partially known, effectively "flattening" the XML for specific attributes.

## Common Patterns
*   **Path-First Optimization:** Used when the application logic relies on a rigid schema where the location of data is predictable.
*   **Value-First Optimization:** Used in "Search" scenarios where users look for specific identifiers (like a Serial Number) that might appear in different sections of various XML documents.
*   **Hybrid Indexing:** Implementing a Primary index for general flexibility and adding specific Secondary indexes only for the most frequent or expensive query paths.

## Anti-Patterns
*   **Over-Indexing:** Creating all types of secondary indexes on every XML column. This leads to massive storage overhead and significantly degrades the performance of `INSERT`, `UPDATE`, and `DELETE` operations.
*   **Indexing Small Documents:** Applying XML indexes to columns where the average XML size is very small (e.g., < 2KB). The overhead of maintaining the index often exceeds the cost of simply parsing the XML at runtime.
*   **Ignoring Base Table Clustering:** Failing to have a robust clustering key on the base table. Since XML indexes must point back to the base row, a weak or volatile primary key on the base table causes index fragmentation.

> [!CAUTION]
> Avoid creating secondary indexes before analyzing query execution plans. Unused secondary indexes consume resources during every data modification without providing any retrieval benefit.

## Edge Cases
*   **Deeply Nested Hierarchy:** XML documents with extreme depth (e.g., 100+ levels) can cause the Primary XML Index to become inefficient due to the complexity of the Path strings or Node IDs.
*   **Large Namespaces:** Extensive use of namespaces increases the size of the internal shredded table, as namespace URIs must be stored or mapped for every node.
*   **Mixed Content:** Elements containing both text and child elements (e.g., ` <p>This is <b>bold</b> text</p> `) can complicate value-based indexing, as the "value" of the parent node may be ambiguous.

## Related Topics
*   **XQuery and XPath:** The query languages used to interact with indexed XML data.
*   **XML Schema Collections (XSD):** Providing a schema can sometimes assist the indexer in optimizing data types.
*   **Selective XML Indexing:** A more modern approach where only specific paths are indexed, rather than the entire document.
*   **Relational Indexing:** The foundational B-tree structures upon which XML indexes are often physically built.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |