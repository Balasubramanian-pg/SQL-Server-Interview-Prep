# 1. B Tree Structure: Root, Intermediate, Leaf

Canonical documentation for 1. B Tree Structure: Root, Intermediate, Leaf. This document defines concepts, terminology, and standard usage.

## Purpose
The B-tree structure exists to provide a self-balancing, multi-way search tree that optimizes data retrieval for systems handling large volumes of data. It addresses the "I/O bottleneck" problem inherent in secondary storage devices (such as HDDs and SSDS) by minimizing the number of disk accesses required to locate a specific record. By maintaining a high branching factor, the B-tree ensures that the distance from the root to any leaf remains minimal, even as the dataset grows exponentially.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the structural invariants that define a B-tree regardless of the specific programming language or storage engine used.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * Structural hierarchy (Root, Intermediate, and Leaf nodes).
> * Node capacity and occupancy invariants.
> * The relationship between keys and child pointers.
> * Balancing requirements across the tree height.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., InnoDB, WiredTiger).
> * Language-specific library syntax.
> * Detailed algorithmic walkthroughs of deletion or insertion (covered in "B Tree Operations").
> * Variations such as B+ Trees or B* Trees, except where necessary for contrast.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Order ($m$) | The maximum number of children a node can have. |
| Key | A unique value within the node used to sort data and guide the search process. |
| Pointer | A reference or address linking a parent node to a child node. |
| Degree ($t$) | Often used interchangeably with order, specifically defining the minimum number of keys a node must contain ($t-1$). |
| Fill Factor | The ratio of currently used slots in a node to the total available slots. |
| Height ($h$) | The number of levels from the root node to the leaf nodes. |

## Core Concepts
The fundamental idea of a B-tree is the distribution of keys across a wide, shallow hierarchy. Unlike binary trees, which allow only two children per node, a B-tree node can have dozens or hundreds of children, significantly reducing the tree's height.

> [!TIP]
> Think of a B-tree like a massive library filing system. The **Root** is the building directory, **Intermediate** nodes are the floor and aisle signs, and **Leaf** nodes are the specific shelves where the books (data) reside. This structure allows you to find one book among millions by checking only three or four signs.

### Structural Invariants
1. **Sorted Order:** Keys within every node are kept in ascending order.
2. **Child Range:** A node with $k$ keys must have exactly $k+1$ children.
3. **Perfect Balance:** All leaf nodes must exist at the exact same depth (the bottom level).
4. **Occupancy Rule:** Every node (except the root) must be at least half-full to ensure efficient space utilization.

## Standard Model
The standard model of a B-tree organizes nodes into three distinct functional layers.

### 1. The Root Node
The root is the unique entry point of the tree. It is the only node that is permitted to violate the minimum occupancy rule (it can have as few as one key and two children). If the entire tree contains fewer than $m$ keys, the root also functions as a leaf.

### 2. Intermediate (Internal) Nodes
Intermediate nodes act as routers. They store keys that act as separators to guide the search algorithm to the correct subtree. They do not represent the "end" of a search; rather, they narrow the search range.
* **Key $K_i$** in an intermediate node ensures all keys in the child to its left are less than $K_i$, and all keys in the child to its right are greater than $K_i$.

### 3. Leaf Nodes
Leaf nodes are the terminal nodes of the tree. They contain the actual data records or pointers to the physical locations of the data. Leaf nodes have no children. In a pure B-tree, data can reside in both intermediate and leaf nodes, whereas in a B+ tree, all data is strictly in the leaves.

## Common Patterns
* **Node Splitting:** When an insertion causes a node to exceed $m-1$ keys, the node splits into two, and the median key is promoted to the parent. This is how the tree grows in height (from the top down).
* **Node Merging:** When a deletion causes a node to fall below the minimum occupancy, it may merge with a sibling or "borrow" a key from a sibling to maintain balance.
* **High Branching Factor:** Standard implementations often use a large order (e.g., $m=100$) to ensure the tree height remains very low (3 or 4 levels) even for billions of records.

## Anti-Patterns
* **Low Fill Factor:** Allowing nodes to remain nearly empty leads to excessive tree height and wasted storage space.
* **Fixed-Size Buffers for Variable Keys:** Using fixed-size nodes for highly variable key lengths can lead to internal fragmentation.
* **Linear Search within Nodes:** In nodes with a very high order, performing a linear search for a key instead of a binary search negates the performance benefits of the structure.

> [!CAUTION]
> Avoid implementations that allow leaves to exist at different depths; this violates the core B-tree definition and results in an unbalanced tree, leading to unpredictable $O(\log n)$ performance.

## Edge Cases
* **The Single-Node Tree:** When the tree is first initialized, the root is also a leaf. The structural rules for intermediate nodes do not apply until the first split occurs.
* **Maximum Height:** Occurs when every node is at its minimum allowed occupancy ($t-1$ keys).
* **Minimum Height:** Occurs when every node is completely full ($m-1$ keys).
* **Empty Tree:** A tree with zero keys is typically represented by a null root or a single empty leaf node.

## Related Topics
* **B+ Tree Structure:** A common variant where all data is stored in leaves and leaves are linked sequentially.
* **B* Tree Structure:** A variant that enforces a higher fill factor (2/3 full) by delaying splits.
* **Disk I/O Optimization:** The underlying physical motivation for the B-tree's wide structure.
* **Search Algorithms:** The logic used to traverse from Root to Leaf.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-13 | Initial AI-generated canonical documentation |